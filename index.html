<!doctype html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>Web IME Pro | 导入与长句修正版</title>
        <style>
            :root {
                --primary: #007aff;
                --bg: #f2f2f7;
                --panel-bg: #ffffff;
                --item-bg: #f9f9f9;
                --item-border: #eee;
                --github-dark: #24292e;
            }
            body {
                font-family: system-ui, sans-serif;
                background: var(--bg);
                margin: 0;
                padding: 15px;
                height: 100vh;
                display: flex;
                justify-content: center;
                overflow: hidden;
            }
            .main-layout {
                display: flex;
                flex-direction: column;
                gap: 15px;
                width: 100%;
                max-width: 1900px;
                height: 96vh;
            }
            .toolbar {
                background: var(--panel-bg);
                padding: 10px 20px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }
            .btn {
                padding: 6px 14px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 12px;
                transition: 0.2s;
                display: flex;
                align-items: center;
                gap: 5px;
            }
            .btn-toggle {
                background: #e5e5ea;
                color: #333;
            }
            .btn-toggle.active {
                background: var(--primary);
                color: white;
            }
            .btn-action {
                background: #34c759;
                color: white;
            }
            .btn-github {
                background: var(--github-dark);
                color: white;
                text-decoration: none;
                margin-left: auto;
            }
            .content-area {
                flex: 1;
                display: flex;
                gap: 15px;
                min-height: 0;
                position: relative;
            }
            .resizer {
                width: 6px;
                background: #ddd;
                cursor: col-resize;
                z-index: 10;
            }
            .resizer-v {
                height: 6px;
                background: #ddd;
                cursor: row-resize;
                z-index: 10;
                margin: 2px 0;
            }
            .history-panel {
                flex: 0 0 260px;
                background: #fff;
                border-radius: 16px;
                padding: 15px;
                display: flex;
                flex-direction: column;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            }
            .center-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-width: 400px;
                max-width: 1000px;
                margin: 0 auto;
            }
            .output-card {
                background: white;
                border-radius: 20px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
                position: relative;
                display: flex;
                flex-direction: column;
                min-height: 100px;
                border: 2px solid transparent;
            }
            .output-card.editing {
                border: 2px solid #ff9500;
            }
            #output-area {
                flex: 1;
                padding: 25px;
                font-size: 24px;
                line-height: 1.6;
                word-break: break-all;
                white-space: pre-wrap;
                overflow-y: auto;
                outline: none;
            }
            .practice-hint {
                color: #d1d1d6;
                pointer-events: none;
            }
            #output-area.locked::after {
                content: "";
                display: inline-block;
                width: 2px;
                height: 28px;
                background: var(--primary);
                vertical-align: middle;
                margin-left: 2px;
                animation: blink 1s infinite;
            }
            @keyframes blink {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0;
                }
            }
            .control-group {
                position: absolute;
                right: 15px;
                bottom: 15px;
                display: flex;
                gap: 8px;
                z-index: 100;
            }
            .input-card {
                background: white;
                padding: 20px;
                border-radius: 20px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                border: 3px solid transparent;
                position: relative;
            }
            .input-card.tab-mode {
                border-color: var(--primary);
                background: #f0f7ff;
            }
            .input-status-bar {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
                min-height: 30px;
            }
            #buffer-display {
                font-size: 18px;
                color: var(--primary);
                font-weight: bold;
            }
            #main-candidates {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                overflow-y: auto;
            }
            .candidate-item {
                position: relative;
                padding: 10px 15px;
                background: var(--item-bg);
                border-radius: 10px;
                cursor: pointer;
                border: 1px solid var(--item-border);
                display: flex;
                flex-direction: column;
                align-items: center;
                min-width: 60px;
            }
            .cand-key {
                position: absolute;
                top: 2px;
                left: 4px;
                font-size: 10px;
                opacity: 0.5;
                color: var(--primary);
                font-weight: bold;
            }
            .cand-text {
                font-size: 22px;
                font-weight: 500;
            }
            .cand-desc {
                font-size: 11px;
                color: #888;
                margin-top: 4px;
            }
            #hidden-input {
                position: fixed;
                left: -999px;
                opacity: 0;
            }

            #correction-wrapper {
                position: absolute;
                bottom: 20px;
                left: 20px;
                right: 20px;
                background: white;
                box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
                border-radius: 12px;
                padding: 15px;
                display: none;
                z-index: 200;
                border: 2px solid var(--primary);
            }
            #correction-input {
                width: 100%;
                font-size: 20px;
                border: none;
                outline: none;
                font-family: system-ui;
                color: #333;
                font-weight: 500;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
            }
            .correction-tip {
                font-size: 12px;
                color: #888;
                margin-top: 8px;
                display: flex;
                justify-content: space-between;
            }

            #toast {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #333;
                color: white;
                padding: 8px 20px;
                border-radius: 20px;
                opacity: 0;
                transition: 0.3s;
                z-index: 999;
                pointer-events: none;
            }
            #file-uploader {
                display: none;
            }
            .dict-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 5px;
                font-size: 13px;
                border-bottom: 1px solid #f5f5f5;
            }
            .dict-name {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 160px;
            }
            .switch {
                position: relative;
                display: inline-block;
                width: 34px;
                height: 20px;
            }
            .switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }
            .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #ccc;
                transition: 0.4s;
                border-radius: 20px;
            }
            .slider:before {
                position: absolute;
                content: "";
                height: 16px;
                width: 16px;
                left: 2px;
                bottom: 2px;
                background-color: white;
                transition: 0.4s;
                border-radius: 50%;
            }
            input:checked + .slider {
                background-color: var(--primary);
            }
            input:checked + .slider:before {
                transform: translateX(14px);
            }
            .history-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 5px; border-bottom: 1px solid #eee; }
            .history-text { flex-grow: 1; cursor: pointer; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
            .history-time { color: #888; font-size: 9px; margin-bottom: 2px; }
            .history-content { font-size: 12px; }
            .delete-btn { color: #ff3b30; cursor: pointer; font-size: 20px; font-weight: bold; padding: 0 5px; border-radius: 50%; visibility: hidden; opacity: 0; transition: .2s; }
            .history-item:hover .delete-btn { visibility: visible; opacity: 1; }
            .dict-item .delete-btn { visibility: visible; opacity: 1; margin-right: 5px; }

            .dict-tabs {
                display: flex;
                border-bottom: 1px solid #eee;
                margin-bottom: 10px;
            }
            .dict-tab {
                padding: 8px 15px;
                cursor: pointer;
                border-bottom: 2px solid transparent;
                margin-bottom: -1px;
                font-size: 13px;
                color: #555;
            }
            .dict-tab.active {
                border-bottom-color: var(--primary);
                color: var(--primary);
                font-weight: bold;
            }
            .dict-language-panel {
                display: none;
            }
            .dict-language-panel.active {
                display: block;
            }
            .dict-level-header {
                font-weight: bold;
                padding: 10px 5px;
                background-color: #f9f9f9;
                border-top: 1px solid #eee;
                border-bottom: 1px solid #eee;
                cursor: pointer;
                font-size: 12px;
                position: relative;
            }
            .dict-level-header::after {
                content: '▼';
                position: absolute;
                right: 10px;
                font-size: 10px;
                transition: transform 0.2s;
            }
            .dict-level-category.collapsed .dict-level-header::after {
                transform: rotate(-90deg);
            }
            .dict-level-category.collapsed .dict-level-content {
                display: none;
            }
        </style>
    </head>
    <body>
        <div class="main-layout">
            <div class="toolbar">
                <button
                    id="l-hist-btn"
                    class="btn btn-toggle"
                    onclick="toggleHistory()"
                >
                    历史记录
                </button>
                <div
                    style="
                        width: 1px;
                        height: 20px;
                        background: #ddd;
                        margin: 0 5px;
                    "
                ></div>
                <button
                    class="btn btn-action"
                    onclick="document.getElementById('file-uploader').click()"
                >
                    导入词库
                </button>


                <button
                    id="practice-btn"
                    class="btn btn-toggle"
                    onclick="togglePracticeMode()"
                >
                    练习模式
                </button>

                <div
                    style="
                        width: 1px;
                        height: 20px;
                        background: #ddd;
                        margin: 0 5px;
                    "
                ></div>

                <input
                    type="file"
                    id="file-uploader"
                    accept=".json"
                    onchange="handleImportDict(this)"
                />

                <a
                    href="https://github.com/123qweraz/webime"
                    target="_blank"
                    class="btn btn-github"
                    >GitHub Star</a
                >
            </div>
            <div class="content-area">
                <div class="history-panel" id="history-panel">
                    <div
                        style="
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            font-weight: bold;
                            font-size: 14px;
                            border-bottom: 1px solid #eee;
                            padding-bottom: 8px;
                        "
                    >
                        <span>最近归档</span>
                        <span onclick="clearHistory()" style="font-size: 11px; color: var(--primary); cursor: pointer; font-weight: normal;">清空全部</span>
                    </div>
                    <div
                        id="history-list"
                        style="
                            flex: 1;
                            overflow-y: auto;
                            margin-top: 10px;
                            min-height: 50px;
                        "
                    ></div>
                    <div
                        style="
                            margin-top: 15px;
                            padding-top: 15px;
                            border-top: 1px solid #eee;
                            font-weight: bold;
                            font-size: 14px;
                        "
                    >
                        词典管理
                    </div>
                    <div
                        id="dict-management-list"
                        style="
                            flex: 1;
                            overflow-y: auto;
                            margin-top: 10px;
                            min-height: 50px;
                        "
                    ></div>
                </div>
                <div class="resizer" id="left-resizer"></div>
                <div class="center-container">
                    <div class="output-card" id="output-card">
                        <div
                            id="output-area"
                            class="locked"
                            spellcheck="false"
                            oninput="syncFromEditor()"
                        ></div>
                        <div class="control-group">
                            <button
                                id="edit-mode-btn"
                                class="btn btn-toggle"
                                onclick="toggleEditMode()"
                            >
                                锁定模式
                            </button>
                            <button
                                class="btn btn-toggle active"
                                style="background: #222"
                                onclick="archiveAndCopy()"
                            >
                                归档并复制
                            </button>
                        </div>
                    </div>
                    <div class="resizer-v" id="center-v-resizer"></div>
                    <div
                        class="input-card"
                        id="input-container"
                        onclick="focusHiddenInput()"
                    >
                        <div class="input-status-bar">
                            <div id="buffer-display"></div>
                            <div id="page-counter"></div>
                        </div>
                        <div id="main-candidates"></div>

                        <div id="correction-wrapper">
                            <input
                                type="text"
                                id="correction-input"
                                autocomplete="off"
                                placeholder="输入拼音短语，用空格分隔，如: ni hao"
                            />
                            <div class="correction-tip">
                                <span>支持长句输入 (空格分隔)</span>
                                <span>Enter 上屏 / Esc 取消</span>
                            </div>
                        </div>

                        <input
                            type="text"
                            id="hidden-input"
                            autocomplete="off"
                        />
                    </div>
                </div>
            </div>
        </div>
        <div id="toast"></div>

        <script>

            const PUNCS = {
                ",": "，",
                ".": "。",
                "!": "！",
                "?": "？",
                ";": "；",
                ":": "：",
                "(": "（",
                ")": "）",
                "[": "【",
                "]": "】",
            };

            function getDictLevel(dict) {
                return typeof dict.level === "number" ? dict.level : 100; // Use 100 as per strong recommendation
            }

            let DB = {};
            let allDicts = [];
            const BUILT_IN_DICTS = [
                {
                    name: "基础词典",
                    path: "dicts/first_dict/dict.json",
                    enabled: true,
                    type: "built-in",
                    language: "chinese",
                    level: 1,
                },
                {
                    name: "词组词典",
                    path: "dicts/first_dict/dict_cizu.json",
                    enabled: true,
                    type: "built-in",
                    language: "chinese",
                    level: 1,
                },
                {
                    name: "英文短词",
                    path: "dicts/first_dict/dict_enlt5s.json",
                    enabled: true,
                    type: "built-in",
                    language: "chinese",
                    level: 1,
                },
                {
                    name: "英文长词",
                    path: "dicts/first_dict/dict_5_10s.json",
                    enabled: true,
                    type: "built-in",
                    language: "chinese",
                    level: 1,
                },
                {
                    name: "二级字词",
                    path: "dicts/second_dict/level-2_char_en.json",
                    enabled: true,
                    type: "built-in",
                    language: "chinese",
                    level: 2,
                },
                {
                    name: "三字词",
                    path: "dicts/second_dict/3字.json",
                    enabled: true,
                    type: "built-in",
                    language: "chinese",
                    level: 2,
                },
                {
                    name: "四字词",
                    path: "dicts/second_dict/4字.json",
                    enabled: true,
                    type: "built-in",
                    language: "chinese",
                    level: 2,
                },
                {
                    name: "四字以上词",
                    path: "dicts/second_dict/4字以上.json",
                    enabled: true,
                    type: "built-in",
                    language: "chinese",
                    level: 2,
                },
                {
                    name: "三级字词",
                    path: "dicts/third_dict/level-3_char_en.json",
                    enabled: false,
                    type: "built-in",
                    language: "chinese",
                    level: 3,
                },
                {
                    name: "日本語 N5",
                    path: "dicts/japanese/n5.json",
                    enabled: true,
                    type: "built-in",
                    language: "japanese",
                    level: 1,
                },
                {
                    name: "日本語 N4",
                    path: "dicts/japanese/n4.json",
                    enabled: false,
                    type: "built-in",
                    language: "japanese",
                    level: 2,
                },
                {
                    name: "日本語 N3",
                    path: "dicts/japanese/n3.json",
                    enabled: false,
                    type: "built-in",
                    language: "japanese",
                    level: 3,
                },
            ];

            let settings = JSON.parse(
                localStorage.getItem("ime_settings") || "{}",
            );
            if (!settings.outputHeight) settings.outputHeight = 300;
            if (typeof settings.history === "undefined")
                settings.history = true;


            let activeLanguage = 'chinese';
            let buffer = "",
                committed = "",
                isTabMode = false,
                enFilter = "",
                isEditMode = false;
            let isPracticeMode = false,
                practiceTargetText = "",
                isCorrectionMode = false;

            let combinedCandidates = [],
                pageIndex = 0;
            const pageSize = 10;
            let HISTORY = JSON.parse(
                localStorage.getItem("ime_history_v18") || "[]",
            );

            const hInput = document.getElementById("hidden-input");
            const outputArea = document.getElementById("output-area");
            const correctionWrapper =
                document.getElementById("correction-wrapper");
            const correctionInput = document.getElementById("correction-input");

            async function init() {
                applySettings();
                loadDictConfig();
                renderDictManagement();
                await loadAllDicts();
                update();
                updateHistoryUI();

                document.getElementById('history-list').addEventListener('click', function(e) {
                    const historyText = e.target.closest('.history-text');
                    if (historyText && historyText.dataset.text) {
                        committed += historyText.dataset.text;
                        update();
                        return;
                    }

                    const deleteBtn = e.target.closest('.delete-btn');
                    if (deleteBtn && deleteBtn.dataset.index) {
                        const index = parseInt(deleteBtn.dataset.index, 10);
                        if (!isNaN(index)) {
                            deleteHistoryItem(index);
                        }
                        return;
                    }
                });
            }

            function loadDictConfig() {
                const storedDicts = JSON.parse(
                    localStorage.getItem("ime_dicts_config"),
                );
                if (storedDicts) {
                    allDicts = storedDicts;
                    BUILT_IN_DICTS.forEach((builtInDict) => {
                        if (
                            !allDicts.find((d) => d.path === builtInDict.path)
                        ) {
                            allDicts.push(builtInDict);
                        }
                    });
                } else {
                    allDicts = [...BUILT_IN_DICTS];
                }
                saveDictConfig();
            }

            function saveDictConfig() {
                localStorage.setItem(
                    "ime_dicts_config",
                    JSON.stringify(allDicts),
                );
            }

            function renderDictManagement() {
                const listEl = document.getElementById("dict-management-list");
                const groupedByLang = allDicts.reduce((acc, dict) => {
                    const lang = dict.language || 'chinese';
                    if (!acc[lang]) {
                        acc[lang] = [];
                    }
                    acc[lang].push(dict);
                    return acc;
                }, {});

                const languages = Object.keys(groupedByLang);
                const levelNames = {
                    chinese: {
                        1: "内置基础", // Updated from "level-1"
                        2: "词组 / 扩展", // Updated from "level-2"
                        3: "高级", // Updated from "level-3"
                        100: "用户导入" // Updated from 0 to 100
                    },
                    japanese: {
                        1: "N5",
                        2: "N4",
                        3: "N3",
                        100: "ユーザーインポート" // Updated from 4 to 100
                    }
                };

                let tabsHTML = languages.map(lang => `<div class="dict-tab" data-lang="${lang}" onclick="switchLanguage('${lang}')">${lang === 'chinese' ? '中文' : '日本語'}</div>`).join('');

                let contentHTML = languages.map(lang => {
                    const dictsInLang = groupedByLang[lang];
                    const currentLevelNames = levelNames[lang] || levelNames['chinese'];
                    const groupedByLevel = dictsInLang.reduce((acc, dict) => {
                        const level = getDictLevel(dict);
                        if (!acc[level]) acc[level] = [];
                        acc[level].push(dict);
                        return acc;
                    }, {});

                    let levelHTML = Object.keys(groupedByLevel).map(Number).sort((a, b) => a - b).map(level => {
                        const dictsInLevel = groupedByLevel[level];
                        let itemsHTML = dictsInLevel.map(dict => {
                            const index = allDicts.indexOf(dict);
                            return `
                                <div class="dict-item">
                                    <span class="dict-name" title="${dict.name}">${dict.name} ${dict.wordCount !== undefined ? `(${dict.wordCount}词)` : ''}</span>
                                    <div style="display: flex; align-items: center;">
                                        ${dict.type === 'user' ? `<div class="delete-btn" style="padding-right: 10px;" title="删除词典" onclick="deleteDict(${index})">&times;</div>` : ''}
                                        <label class="switch">
                                            <input type="checkbox" ${dict.enabled ? "checked" : ""} onchange="toggleDict(${index})">
                                            <span class="slider"></span>
                                        </label>
                                    </div>
                                </div>`;
                        }).join('');

                        return `
                            <div class="dict-level-category">
                                <div class="dict-level-header" onclick="this.parentElement.classList.toggle('collapsed')">${currentLevelNames[level]}</div>
                                <div class="dict-level-content">${itemsHTML}</div>
                            </div>`;
                    }).join('');
                    
                    return `<div class="dict-language-panel" data-lang="${lang}">${levelHTML}</div>`;
                }).join('');

                listEl.innerHTML = `<div class="dict-tabs">${tabsHTML}</div><div class="dict-content">${contentHTML}</div>`;

                // Activate the active tab
                switchLanguage(activeLanguage);
            }

            function switchLanguage(lang) {
                activeLanguage = lang;
                const tabs = document.querySelectorAll('.dict-tab');
                tabs.forEach(tab => tab.classList.toggle('active', tab.dataset.lang === lang));
                const panels = document.querySelectorAll('.dict-language-panel');
                panels.forEach(panel => panel.classList.toggle('active', panel.dataset.lang === lang));
            }

            async function deleteDict(index) {
                const dict = allDicts[index];
                if (dict.type !== 'user') {
                    showToast("内置词典无法删除。");
                    return;
                }
                if (confirm(`确定要删除导入的词典 "${dict.name}" 吗？此操作无法撤销。`)) {
                    allDicts.splice(index, 1);
                    saveDictConfig();
                    renderDictManagement();
                    showToast("词典已删除，正在刷新...");
                    await loadAllDicts();
                    update();
                }
            }

            async function toggleDict(index) {
                allDicts[index].enabled = !allDicts[index].enabled;
                saveDictConfig();
                showToast("词典设置已更新，正在重新加载...");
                await loadAllDicts();
                update();
            }

            function mergeIntoDict(targetDict, newDict) {
                for (let k in newDict) {
                    let key = k.toLowerCase();
                    if (!targetDict[key]) targetDict[key] = [];
                    const newItems = Array.isArray(newDict[k])
                        ? newDict[k]
                        : [newDict[k]];
                    targetDict[key] = targetDict[key].concat(newItems);
                }
            }

            function calculateWordCount(dictContent) {
                let count = 0;
                for (const k in dictContent) {
                    count += Array.isArray(dictContent[k])
                        ? dictContent[k].length
                        : 1;
                }
                return count;
            }

            async function loadAllDicts() {
                DB = {};
                const loadPromises = allDicts
                    .filter((d) => d.enabled)
                    .map((dict, index) => {
                        return new Promise(async (resolve) => {
                            try {
                                let dictData;
                                if (dict.type === "built-in") {
                                    const r = await fetch(dict.path);
                                    if (!r.ok) return resolve();
                                    dictData = await r.json();
                                    mergeIntoDict(DB, dictData);
                                } else if (
                                    dict.type === "user" &&
                                    dict.content
                                ) {
                                    dictData = JSON.parse(dict.content);
                                    mergeIntoDict(DB, dictData);
                                }
                                if (dictData && allDicts[index]) { // Ensure allDicts[index] exists before updating
                                    allDicts[index].wordCount = calculateWordCount(dictData);
                                }
                            } catch (e) {
                                console.error(
                                    "Failed to load or parse dict:",
                                    dict.name,
                                    e,
                                );
                            }
                            resolve();
                        });
                    });
                await Promise.all(loadPromises);
                console.log("All enabled dicts loaded.");
                renderDictManagement(); // Re-render to show updated counts
            }

            function applySettings() {
                document.getElementById("output-card").style.height =
                    settings.outputHeight + "px";
                document.getElementById("history-panel").style.display =
                    settings.history ? "flex" : "none";
                document
                    .getElementById("l-hist-btn")
                    .classList.toggle("active", settings.history);

            }

            function handleImportDict(input) {
                const file = input.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async function (e) {
                    try {
                        const content = e.target.result;
                        const dictData = JSON.parse(content); // Parse content to get dictData
                        
                        const newDict = {
                            name: file.name,
                            enabled: true,
                            type: 'user',
                            content: content,
                            wordCount: calculateWordCount(dictData), // Calculate count here
                            language: 'chinese',
                            level: 100
                        };

                        allDicts.push(newDict);
                        saveDictConfig();
                        renderDictManagement();
                        
                        showToast(`成功导入词库: ${file.name}, 正在重新加载...`);
                        await loadAllDicts();
                        update();
                        
                        input.value = "";
                    } catch (err) {
                        alert("词库文件格式错误，请确保是标准的 JSON 格式。");
                        console.error(err);
                    }
                };
                reader.readAsText(file);
            }

            function update() {
                if (isEditMode) return;

                if (isPracticeMode && practiceTargetText) {
                    if (practiceTargetText.startsWith(committed)) {
                        const remaining = practiceTargetText.substring(
                            committed.length,
                        );
                        outputArea.innerHTML =
                            escapeHtml(committed) +
                            `<span class="practice-hint">${escapeHtml(remaining)}</span>`;
                    } else {
                        outputArea.innerText = committed;
                    }
                    if (committed === practiceTargetText) {
                        setTimeout(() => {
                            committed = "";
                            generatePracticeText();
                            update();
                            showToast("不错！下一组");
                        }, 200);
                    }
                } else {
                    outputArea.innerText = committed;
                }
                outputArea.scrollTop = outputArea.scrollHeight;

                if (buffer) {
                    const b = buffer.toLowerCase();
                    let bufferHTML = escapeHtml(buffer);
                    if (isTabMode) {
                        bufferHTML += "-";
                        if (enFilter) {
                            bufferHTML += ` <span style="color: #ff9500;">${escapeHtml(enFilter)}</span>`;
                        }
                    }
                    document.getElementById("buffer-display").innerHTML = bufferHTML;
                    
                    let list = [];
                    const isAllVowels = (str) => /^[aeiou]+$/.test(str);

                    let useExactMatch = false;
                    if (b.length <= 2) {
                        useExactMatch = true;
                    } else if ((b.length === 3 || b.length === 4) && isAllVowels(b)) {
                        useExactMatch = true;
                    }

                    for (let key in DB) {
                        const match = useExactMatch ? key === b : key.startsWith(b);
                        if (match) {
                            let weight = 1000;
                            if (key === b) weight += 10000;
                            weight -= (key.length - b.length) * 100;
                            DB[key].forEach((i) =>
                                list.push({
                                    text: i.char || i,
                                    desc:
                                        i.en ||
                                        (typeof i === "object" ? i.en : ""),
                                    w: weight,
                                }),
                            );
                        }
                    }

                                                            const seen = new Set();

                                                            combinedCandidates = list

                                                                .sort((a, b) => b.w - a.w)

                                                                .filter((x) => !seen.has(x.text) && seen.add(x.text));

                                        

                                                            if (

                                                                b.length >= 6 &&

                                                                DB[b] &&

                                                                DB[b].length === 1 &&

                                                                combinedCandidates.length === 1 &&

                                                                !isTabMode

                                                            ) {

                                                                const word = combinedCandidates[0].text;

                                                                setTimeout(() => selectCandidate(word), 10);

                                                                return;

                                                            }

                                                        } else {                    document.getElementById("buffer-display").innerText = "";
                    combinedCandidates = [];
                }
                render();
            }

            function escapeHtml(text = "") {
                return String(text)
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            }

            function render() {
                let display = combinedCandidates;
                if (isTabMode && enFilter) {
                    display = combinedCandidates.filter(
                        (i) =>
                            i.desc &&
                            i.desc
                                .toLowerCase()
                                .startsWith(enFilter.toLowerCase()),
                    );
                    if (display.length === 1) {
                        selectCandidate(display[0].text);
                        return;
                    }
                }
                const totalPages = Math.ceil(display.length / pageSize);
                document.getElementById("page-counter").innerText =
                    buffer && display.length > 0
                        ? `${pageIndex + 1} / ${totalPages || 1}`
                        : "";
                const pageData = display.slice(
                    pageIndex * pageSize,
                    (pageIndex + 1) * pageSize,
                );
                document.getElementById("main-candidates").innerHTML = pageData
                    .map(
                        (item, i) => `
                    <div class="candidate-item" onclick="selectCandidate('${item.text}')">
                        <span class="cand-key">${(i + 1) % 10}</span><div class="cand-text">${item.text}</div>
                        ${item.desc ? `<div class="cand-desc">${item.desc}</div>` : ""}
                    </div>`,
                    )
                    .join("");
            }

            function selectCandidate(t) {
                committed += t;
                resetInput();
                update();
            }

            function resetInput() {
                buffer = "";
                enFilter = "";
                isTabMode = false;
                pageIndex = 0;
                hInput.value = "";
            }

            hInput.addEventListener("keydown", (e) => {
                if (isEditMode || isCorrectionMode) return;
                const key = e.key;

                if (e.ctrlKey && key.toLowerCase() === "i") {
                    e.preventDefault();
                    enterCorrectionMode();
                    return;
                }

                if (PUNCS[key]) {
                    e.preventDefault();
                    if (buffer && combinedCandidates.length > 0)
                        committed += combinedCandidates[0].text;
                    committed += PUNCS[key];
                    resetInput();
                    update();
                    return;
                }

                if (buffer && !isTabMode) {
                    if (key === "=") {
                        e.preventDefault();
                        if (
                            (pageIndex + 1) * pageSize <
                            combinedCandidates.length
                        ) {
                            pageIndex++;
                            render();
                        }
                        return;
                    }
                    if (key === "-") {
                        e.preventDefault();
                        if (pageIndex > 0) {
                            pageIndex--;
                            render();
                        }
                        return;
                    }
                }

                if (key === "Tab") {
                    e.preventDefault();
                    if (buffer) {
                        isTabMode = !isTabMode;
                        enFilter = "";
                        update();
                    }
                    return;
                }

                if (isTabMode && buffer) {
                    if (/^[a-zA-Z]$/.test(key)) {
                        e.preventDefault();
                        enFilter += key.toLowerCase();
                        pageIndex = 0;
                        render();
                        return;
                    }
                    if (key === "Backspace") {
                        e.preventDefault();
                        if (enFilter) {
                            enFilter = enFilter.slice(0, -1);
                            render();
                        } else {
                            isTabMode = false;
                            update();
                        }
                        return;
                    }
                }

                if (/^[0-9]$/.test(key)) {
                    e.preventDefault();
                    const idx = key === "0" ? 9 : parseInt(key) - 1;
                    const list =
                        isTabMode && buffer
                            ? combinedCandidates.filter((c) =>
                                  c.desc?.toLowerCase().startsWith(enFilter),
                              )
                            : combinedCandidates;
                    const pageData = list.slice(
                        pageIndex * pageSize,
                        (pageIndex + 1) * pageSize,
                    );
                    if (pageData[idx]) selectCandidate(pageData[idx].text);
                } else if (key === "Enter") {
                    e.preventDefault();
                    if (buffer) {
                        committed += buffer;
                        resetInput();
                    } else {
                        committed += "\n";
                    }
                    update();
                } else if (key === "Backspace" && !buffer) {
                    e.preventDefault();
                    committed = committed.slice(0, -1);
                    update();
                } else if (key === " " && buffer) {
                    e.preventDefault();
                    const list =
                        isTabMode && buffer
                            ? combinedCandidates.filter((c) =>
                                  c.desc?.toLowerCase().startsWith(enFilter),
                              )
                            : combinedCandidates;
                    const pageData = list.slice(
                        pageIndex * pageSize,
                        (pageIndex + 1) * pageSize,
                    );
                    if (pageData[0]) selectCandidate(pageData[0].text);
                }
            });

            document.addEventListener("keydown", (e) => {
                const key = e.key.toLowerCase();
                if (e.ctrlKey && key === "e") {
                    e.preventDefault();
                    toggleEditMode();
                    return;
                }
                if (e.ctrlKey && key === "c") {
                    if (!isEditMode && !isCorrectionMode) {
                        e.preventDefault();
                        archiveAndCopy();
                    }
                    return;
                }
                if (e.key === "Escape") {
                    if (isEditMode) toggleEditMode();
                    if (isCorrectionMode) {
                        e.preventDefault();
                        exitCorrectionMode('update_buffer');
                    }
                }
            });

            hInput.addEventListener("input", () => {
                if (!isTabMode && !isEditMode) {
                    buffer = hInput.value.replace(/[^a-zA-Z]/g, "");
                    pageIndex = 0;
                    update();
                }
            });

            function enterCorrectionMode() {
                isCorrectionMode = true;
                correctionWrapper.style.display = "block";
                correctionInput.value = buffer;
                correctionInput.focus();
                correctionInput.setSelectionRange(
                    correctionInput.value.length,
                    correctionInput.value.length,
                );
            }

            function exitCorrectionMode(action) {
                isCorrectionMode = false;
                correctionWrapper.style.display = "none";
                const raw = correctionInput.value.trim();

                if (action === 'update_buffer') {
                    // Reset tab/page state, then set buffer from correction input and update candidates
                    enFilter = "";
                    isTabMode = false;
                    pageIndex = 0;
                    buffer = raw.replace(/[^a-zA-Z]/g, "");
                    hInput.value = buffer;
                    update();
                } else if (action === 'convert_sentence') {
                    if (raw) {
                        const result = convertSentence(raw);
                        committed += result;
                        resetInput();
                        update();
                    }
                }
                // If action is anything else (e.g. undefined on blur), just cancel.
                focusHiddenInput();
            }

            function convertSentence(inputStr) {
                const segments = inputStr.split(/\s+/);
                let finalStr = "";
                for (const seg of segments) {
                    if (!seg) continue;
                    if (/^[a-zA-Z]+$/.test(seg)) {
                        const lowSeg = seg.toLowerCase();
                        let best =
                            DB[lowSeg] && DB[lowSeg][0] ? DB[lowSeg][0] : null;

                        if (best) {
                            finalStr +=
                                typeof best === "object" ? best.char : best;
                        } else {
                            finalStr += seg;
                        }
                    } else {
                        finalStr += seg;
                    }
                }
                return finalStr;
            }

            correctionInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    exitCorrectionMode('convert_sentence');
                } else if (e.key === "Escape") {
                    e.preventDefault();
                    exitCorrectionMode('update_buffer');
                } else if (e.ctrlKey && e.key.toLowerCase() === "i") {
                    e.preventDefault();
                    exitCorrectionMode('convert_sentence');
                }
            });

            function togglePracticeMode() {
                isPracticeMode = !isPracticeMode;
                document
                    .getElementById("practice-btn")
                    .classList.toggle("active", isPracticeMode);
                if (isPracticeMode) {
                    committed = "";
                    generatePracticeText();
                    showToast("进入练习模式");
                } else {
                    practiceTargetText = "";
                    committed = "";
                    showToast("退出练习模式");
                }
                update();
                focusHiddenInput();
            }

            function generatePracticeText() {
                let allWords = [];
                for (let k in DB) {
                    DB[k].forEach((item) => {
                        const text =
                            typeof item === "object" ? item.char : item;
                        if (text.length > 1) allWords.push(text);
                    });
                }
                if (allWords.length === 0) {
                    practiceTargetText = "词库为空，请先加载或导入词库。";
                    return;
                }
                const COUNT = 5;
                let result = "";
                for (let i = 0; i < COUNT; i++) {
                    const rand =
                        allWords[Math.floor(Math.random() * allWords.length)];
                    result += rand + "，";
                }
                result = result.slice(0, -1) + "。";
                practiceTargetText = result;
            }



            function toggleHistory() {
                settings.history = !settings.history;
                document.getElementById("history-panel").style.display =
                    settings.history ? "flex" : "none";
                document
                    .getElementById("l-hist-btn")
                    .classList.toggle("active", settings.history);
                saveSettings();
            }

            function saveSettings() {
                localStorage.setItem("ime_settings", JSON.stringify(settings));
            }

            function toggleEditMode() {
                isEditMode = !isEditMode;
                outputArea.contentEditable = isEditMode;
                outputArea.classList.toggle("locked", !isEditMode);
                const btn = document.getElementById("edit-mode-btn");
                btn.innerText = isEditMode ? "编辑中 (ESC退出)" : "锁定模式";
                btn.classList.toggle("active", isEditMode);
                document
                    .getElementById("output-card")
                    .classList.toggle("editing", isEditMode);
                if (isEditMode) {
                    outputArea.focus();
                    if (window.getSelection && document.createRange) {
                        const range = document.createRange();
                        range.selectNodeContents(outputArea);
                        range.collapse(false);
                        const sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                } else {
                    committed = outputArea.innerText;
                    resetInput();
                    update();
                    focusHiddenInput();
                }
            }

            function syncFromEditor() {
                if (isEditMode) committed = outputArea.innerText;
            }

            function archiveAndCopy() {
                if (!committed) return;
                navigator.clipboard.writeText(committed).then(() => {
                    HISTORY.unshift({
                        text: committed,
                        time: new Date().toLocaleTimeString(),
                    });
                    localStorage.setItem(
                        "ime_history_v18",
                        JSON.stringify(HISTORY.slice(0, 30)),
                    );
                    committed = "";
                    updateHistoryUI();
                    update();
                    showToast("已归档并复制");
                });
            }

            function clearHistory() {
                if (confirm('确定要清空所有历史记录吗？')) {
                    HISTORY = [];
                    localStorage.setItem("ime_history_v18", "[]");
                    updateHistoryUI();
                    showToast("历史记录已清空");
                }
            }

            function deleteHistoryItem(index) {
                HISTORY.splice(index, 1);
                localStorage.setItem("ime_history_v18", JSON.stringify(HISTORY));
                updateHistoryUI();
            }

            function updateHistoryUI() {
                document.getElementById("history-list").innerHTML = HISTORY.map(
                    (h, i) =>
                        `<div class="history-item">
                            <div class="history-text" title="点击以上屏" data-text="${escapeHtml(h.text)}">
                                <div class="history-time">${h.time}</div>
                                <div class="history-content">${escapeHtml(h.text.substring(0, 30))}${h.text.length > 30 ? '...' : ''}</div>
                            </div>
                            <div class="delete-btn" title="删除此条" data-index="${i}">&times;</div>
                        </div>`,
                ).join("");
            }

            function showToast(m) {
                const t = document.getElementById("toast");
                t.innerText = m;
                t.style.opacity = 1;
                setTimeout(() => (t.style.opacity = 0), 2000);
            }

            function focusHiddenInput() {
                if (!isEditMode && !isCorrectionMode) hInput.focus();
            }

            document.addEventListener("click", (e) => {
                if (isEditMode && outputArea.contains(e.target)) return;
                if (isCorrectionMode && correctionWrapper.contains(e.target))
                    return;
                if (e.target.id === "file-uploader") return;
                focusHiddenInput();
            });

            function makeResizableV(id, targetId) {
                const h = document.getElementById(id),
                    t = document.getElementById(targetId);
                h.addEventListener("mousedown", (e) => {
                    const startY = e.clientY,
                        startH = t.offsetHeight;
                    const drag = (ev) => {
                        const newH = startH + (ev.clientY - startY);
                        t.style.height = newH + "px";
                        settings.outputHeight = newH;
                    };
                    const stop = () => {
                        document.removeEventListener("mousemove", drag);
                        saveSettings();
                    };
                    document.addEventListener("mousemove", drag);
                    document.addEventListener("mouseup", stop);
                });
            }

            document.addEventListener("DOMContentLoaded", () => {
                makeResizableV("center-v-resizer", "output-card");
            });

            init();
            setInterval(focusHiddenInput, 1000);
        </script>
    </body>
</html>
