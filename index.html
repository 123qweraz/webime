<!doctype html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>Pinyin Input Method</title>
        <script>
            const BUILT_IN_DICTS = [
                {
                    name: "‰∏ÄÁ∫ßÂ≠ó",
                    path: "dicts/first_dict/dict.json",
                    enabled: true,
                    type: "built-in",
                },
                {
                    name: "ËØçÁªÑËØçÂÖ∏",
                    path: "dicts/first_dict/dict_cizu.json",
                    enabled: true,
                    type: "built-in",
                },
                {
                    name: "‰∫åÁ∫ßÂ≠ó",
                    path: "dicts/second_dict/level-2_char_en.json",
                    enabled: true,
                    type: "built-in",
                },
                {
                    name: "‰∏âÁ∫ßÂ≠ó",
                    path: "dicts/third_dict/level-3_char_en.json",
                    enabled: true,
                    type: "built-in",
                },
                {
                    name: "‰∏âÂ≠óËØçËØ≠",
                    path: "dicts/third_dict/three_character_word.json",
                    enabled: true,
                    type: "built-in",
                },
                {
                    name: "ÂõõÂ≠óËØçËØ≠",
                    path: "dicts/third_dict/four_character_word.json",
                    enabled: true,
                    type: "built-in",
                },
                {
                    name: "N5",
                    path: "dicts/japanese/N5.json",
                    enabled: false,
                    type: "built-in",
                },
                {
                    name: "N4",
                    path: "dicts/japanese/N4.json",
                    enabled: false,
                    type: "built-in",
                },
                {
                    name: "N3",
                    path: "dicts/japanese/N3.json",
                    enabled: false,
                    type: "built-in",
                },
                {
                    name: "N2",
                    path: "dicts/japanese/N2.json",
                    enabled: false,
                    type: "built-in",
                },
                {
                    name: "N1",
                    path: "dicts/japanese/N1.json",
                    enabled: false,
                    type: "built-in",
                },
            ];
        </script>
        <style>
            :root {
                --primary: #007aff;
                --bg: #f2f2f7;
                --panel-bg: #ffffff;
                --item-bg: #f9f9f9;
                --item-border: #eee;
                --github-dark: #24292e;
            }
            body {
                font-family: system-ui, sans-serif;
                background: var(--bg);
                margin: 0;
                padding: 15px;
                height: 100vh;
                display: flex;
                justify-content: center;
                overflow: hidden;
            }
            .main-layout {
                display: flex;
                flex-direction: column;
                gap: 15px;
                width: 100%;
                max-width: 1900px;
                height: 96vh;
            }
            .toolbar {
                background: var(--panel-bg);
                padding: 10px 20px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }
            .btn {
                padding: 6px 14px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 12px;
                transition: 0.2s;
                display: flex;
                align-items: center;
                gap: 5px;
            }
            .btn-toggle {
                background: #e5e5ea;
                color: #333;
            }
            .btn-toggle.active {
                background: var(--primary);
                color: white;
            }
            .btn-action {
                background: #34c759;
                color: white;
            }
            .btn-github {
                background: var(--github-dark);
                color: white;
                text-decoration: none;
                margin-left: auto;
            }
            .content-area {
                flex: 1;
                display: flex;
                gap: 15px;
                min-height: 0;
                position: relative;
            }
            .resizer {
                width: 6px;
                background: #ddd;
                cursor: col-resize;
                z-index: 10;
            }
            .resizer-v {
                height: 6px;
                background: #ddd;
                cursor: row-resize;
                z-index: 10;
                margin: 2px 0;
            }
            .history-panel {
                flex: 0 0 260px;
                background: #fff;
                border-radius: 16px;
                padding: 15px;
                display: flex;
                flex-direction: column;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            }
            .center-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-width: 400px;
                max-width: 1000px;
                margin: 0 auto;
            }
            .output-card {
                background: white;
                border-radius: 20px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
                position: relative;
                display: flex;
                flex-direction: column;
                min-height: 100px;
                border: 2px solid transparent;
                flex-grow: 2; /* Initial flex-grow for 2/5 height */
                flex-shrink: 0;
            }
            .output-card.editing {
                border: 2px solid #ff9500;
            }
            #output-area {
                flex: 1;
                padding: 25px;
                font-size: 24px;
                line-height: 1.6;
                word-break: break-all;
                white-space: pre-wrap;
                overflow-y: auto;
                outline: none;
            }
            .practice-hint {
                color: #d1d1d6;
                pointer-events: none;
            }
            .caret {
                display: inline-block;
                width: 2px;
                height: 1em;
                background: var(--primary);
                animation: blink 1s infinite;
                vertical-align: bottom;
            }

            .practice-char .caret {
                margin-left: 0;
            }

            #output-area.locked::after {
                content: "";
                display: inline-block;
                width: 2px;
                height: 28px;
                background: var(--primary);
                vertical-align: middle;
                margin-left: 2px;
                animation: blink 1s infinite;
            }
            @keyframes blink {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0;
                }
            }
            .control-group {
                position: absolute;
                right: 15px;
                bottom: 15px;
                display: flex;
                gap: 8px;
                z-index: 100;
            }
            .input-card {
                background: white;
                padding: 20px;
                border-radius: 20px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
                flex: 3; /* Initial flex-grow for 3/5 height */
                flex-shrink: 0;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                border: 3px solid transparent;
                position: relative;
            }
            .input-card.tab-mode {
                border-color: var(--primary);
                background: #f0f7ff;
            }
            #practice-input-display {
                min-height: 40px;
                font-size: 24px;
                line-height: 1.6;
                padding: 10px 0;
                color: #d1d1d6; /* Initial gray color */
                white-space: pre-wrap;
                word-break: break-all;
            }
            #practice-input-display .correct-char {
                color: #333; /* Black for correct characters */
            }
            #practice-input-display .incorrect-char {
                color: red; /* Red for incorrect characters */
            }
            .input-status-bar {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
                min-height: 30px;
            }
            #buffer-display {
                font-size: 18px;
                color: var(--primary);
                font-weight: bold;
                margin-bottom: 5px;
            }
            #main-candidates {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                min-height: 50px;
            }
            .candidate-item {
                position: relative;
                padding: 10px 15px;
                background: var(--item-bg);
                border-radius: 10px;
                cursor: pointer;
                font-size: 22px;
                font-weight: 500;
                border: 1px solid var(--item-border);
                transition: background-color 0.2s;
            }
            .candidate-item:hover {
                background-color: #e0e0e0;
            }
            .completion-item {
                position: relative;
                padding: 6px 10px;
                background: #e9e9eb;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 400;
                color: #555;
                border: 1px solid #ddd;
                transition: background-color 0.2s;
                margin-bottom: 5px; /* Add some space between completion items */
            }
            .completion-item:hover {
                background-color: #d8d8da;
            }
            .completion-header {
                font-size: 14px;
                color: #888;
                margin-top: 10px;
                margin-bottom: 5px;
                border-bottom: 1px solid #eee;
                padding-bottom: 3px;
            }
            .cand-key {
                position: absolute;
                top: 2px;
                left: 4px;
                font-size: 10px;
                opacity: 0.5;
                color: var(--primary);
                font-weight: bold;
            }
            #hidden-input {
                position: fixed;
                left: -999px;
                opacity: 0;
            }

            #correction-wrapper {
                position: absolute;
                bottom: 20px;
                left: 20px;
                right: 20px;
                background: white;
                box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
                border-radius: 12px;
                padding: 15px;
                display: none;
                z-index: 200;
                border: 2px solid var(--primary);
            }
            #correction-input {
                width: 100%;
                font-size: 20px;
                border: none;
                outline: none;
                font-family: system-ui;
                color: #333;
                font-weight: 500;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
            }
            .correction-tip {
                font-size: 12px;
                color: #888;
                margin-top: 8px;
                display: flex;
                justify-content: space-between;
            }

            #toast {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #333;
                color: white;
                padding: 8px 20px;
                border-radius: 20px;
                opacity: 0;
                transition: 0.3s;
                z-index: 999;
                pointer-events: none;
            }
            #file-uploader {
                display: none;
            }
            .history-panel {
                flex: 0 0 260px; /* Maintain initial width, allow it to be a flex item */
                height: 100%; /* Take full height of content-area */
                background: #fff;
                border-radius: 16px;
                padding: 15px;
                display: flex; /* Changed from 'none' to 'flex' for flex layout */
                flex-direction: column;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
                z-index: 1000;
                overflow: hidden;
                margin-right: 15px; /* Add some spacing to the right */
            }
            .history-header {
                padding: 12px 16px;
                background: #f5f5f5;
                border-bottom: 1px solid #ddd;
                font-weight: bold;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .history-list {
                list-style: none;
                padding: 0;
                margin: 0;
                max-height: 350px;
                overflow-y: auto;
            }
            .history-item {
                padding: 10px 16px;
                border-bottom: 1px solid #f0f0f0;
                cursor: pointer;
                transition: background 0.2s;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .history-item:hover {
                background: #f8f8f8;
            }
            .history-item.empty {
                color: #999;
                cursor: default;
            }
            .history-item.empty:hover {
                background: transparent;
            }
            .history-time {
                font-size: 12px;
                color: #666;
                min-width: 50px;
            }
            .history-text {
                flex: 1;
                margin-left: 10px;
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
            }
            .history-delete-btn {
                background: none;
                border: none;
                color: #cc0000;
                font-size: 18px;
                cursor: pointer;
                padding: 0 5px;
                margin-left: 10px;
                opacity: 0.6;
                transition: opacity 0.2s;
            }
            .history-delete-btn:hover {
                opacity: 1;
            }
            .input-method-toast {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: #333;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 9999;
                display: flex;
                align-items: center;
                gap: 10px;
                opacity: 0;
                transform: translateY(20px);
                transition:
                    opacity 0.3s,
                    transform 0.3s;
                max-width: 300px;
                font-size: 14px;
            }
            .input-method-toast.show {
                opacity: 1;
                transform: translateY(0);
            }
            .toast-success {
                background: #4caf50;
                border-left: 4px solid #2e7d32;
            }
            .toast-error {
                background: #f44336;
                border-left: 4px solid #c62828;
            }
            .toast-warning {
                background: #ff9800;
                border-left: 4px solid #ef6c00;
            }
            .toast-info {
                background: #2196f3;
                border-left: 4px solid #1565c0;
            }
            .toast-icon {
                font-weight: bold;
                font-size: 16px;
            }
            .toast-content {
                flex: 1;
            }
            .toast-close {
                background: transparent;
                border: none;
                color: white;
                font-size: 18px;
                cursor: pointer;
                padding: 0 5px;
                opacity: 0.7;
                transition: opacity 0.2s;
            }
            .toast-close:hover {
                opacity: 1;
            }
            #loading-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 255, 255, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                flex-direction: column;
                z-index: 1000;
                font-size: 24px;
                color: var(--primary);
                display: none; /* Hidden by default */
            }
            #loading-spinner {
                border: 4px solid #f3f3f3;
                border-top: 4px solid var(--primary);
                border-radius: 50%;
                width: 40px;
                height: 40px;
                animation: spin 1s linear infinite;
                margin-bottom: 20px;
            }
            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }
            /* New Modal Styles */
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.4);
                backdrop-filter: blur(4px);
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .modal-content {
                background: white;
                width: 90%;
                max-width: 500px;
                max-height: 80vh;
                border-radius: 16px;
                padding: 20px;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            }
            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
                padding-bottom: 10px;
                border-bottom: 1px solid #eee;
            }
            .modal-header h3 {
                margin: 0;
                font-size: 24px;
                color: #333;
                border-bottom: 2px solid var(--primary);
                padding-bottom: 10px;
            }
            .modal-header button {
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #999;
            }
            .import-section {
                margin-bottom: 20px;
                padding-bottom: 15px;
                border-bottom: 1px solid #eee;
            }
            .modal-controls {
                margin-bottom: 20px;
                display: flex;
                gap: 10px;
            }
            .dict-sections h4 {
                margin-top: 20px;
                margin-bottom: 10px;
                color: #555;
            }
            .dict-list {
                min-height: 50px;
                border: 1px dashed #ccc;
                border-radius: 8px;
                margin-bottom: 20px;
                padding: 10px;
                background: #f9f9f9;
            }
            .dict-card {
                background: #f5f5f7;
                padding: 10px;
                margin: 5px 0;
                border-radius: 8px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            }
            .dict-card.disabled {
                opacity: 0.6;
                background: #e0e0e0;
            }
            .dict-card-name {
                flex-grow: 1;
                font-weight: 500;
                color: #333;
            }
            .dict-card-actions {
                display: flex; /* Make buttons arrange horizontally */
                gap: 8px; /* Add some space between buttons */
                align-items: center; /* Vertically align buttons */
            }
            .dict-card-actions button {
                background: none;
                border: none;
                font-size: 16px;
                cursor: pointer;
                color: var(--primary);
            }
            .dict-card-actions button.toggle-off {
                color: #ccc;
            }
            .dict-card-actions button.delete {
                color: #cc0000;
            }

            /* Practice Mode Styles */
            #practice-container {
                display: none; /* Controlled by JS */
                flex-grow: 2;
                flex-shrink: 0;
                flex-direction: row; /* Changed to row for horizontal cards */
                align-items: center; /* Vertically align cards */
                justify-content: center; /* Center cards horizontally */
                position: relative;
                border-radius: 20px;
                /* background: white; Removed as slots will have background */
                /* box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06); Removed */
                overflow: hidden; /* Ensure cards stay within boundary */
                gap: 20px; /* Space between cards */
                padding: 20px; /* Padding inside the container */
            }

            .practice-card-slot {
                width: 320px;
                height: 180px;
                background: var(--panel-bg);
                border-radius: 20px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
                display: flex;
                flex-direction: column; /* Stack pinyin and hanzi */
                align-items: center;
                justify-content: center;
                font-family: "KaiTi", "STKaiti", serif;
                border: 2px solid var(--item-border);
                transition: all 0.5s ease-in-out; /* Smooth transition for movement */
                position: relative; /* For pinyin display positioning */
                opacity: 0; /* Hidden by default */
                transform: scale(0.8); /* Slightly smaller by default */
            }

            .practice-card-slot.visible {
                opacity: 1;
                transform: scale(1);
            }

            .practice-card-slot.current {
                border-color: var(--primary); /* Highlight current card */
            }

            .practice-card-slot.incorrect {
                animation: shake 0.4s;
            }

            .practice-card-content {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                width: 100%;
                height: 100%;
            }

            .pinyin-display {
                font-size: 28px; /* Slightly smaller for pinyin */
                color: #888;
                margin-bottom: 5px;
                text-align: center;
                padding: 0 10px;
            }

            .hanzi-display {
                font-size: 60px;
                font-weight: bold;
                color: #333;
                text-align: center;
                padding: 0 10px;
            }

            #progress-container {
                position: absolute;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                width: 80%;
                max-width: 400px;
                height: 16px;
                background: #e0e0e0;
                border-radius: 8px;
                overflow: hidden;
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
            }

            #progress-bar {
                height: 100%;
                width: 0%;
                background: var(--primary);
                border-radius: 8px;
                transition: width 0.3s ease;
            }

            /* Animations are kept the same */
            .practice-card-fall {
                animation: fall 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55)
                    forwards;
            }

            .practice-card-fly-away {
                animation: fly-away 0.6s ease-in forwards;
            }

            .practice-card-shake {
                animation: shake 0.4s;
            }

            @keyframes fall {
                from {
                    transform: translateY(-300%) rotate(-15deg);
                    opacity: 0;
                }
                to {
                    transform: translateY(0) rotate(0);
                    opacity: 1;
                }
            }

            @keyframes fly-away {
                from {
                    transform: translateX(0) rotate(0deg);
                    opacity: 1;
                }
                to {
                    transform: translateX(150vw) rotate(60deg);
                    opacity: 0;
                }
            }

            @keyframes shake {
                10%,
                90% {
                    transform: translateX(-2px);
                }
                20%,
                80% {
                    transform: translateX(4px);
                }
                30%,
                50%,
                70% {
                    transform: translateX(-8px);
                }
                40%,
                60% {
                    transform: translateX(8px);
                }
            }
        </style>
    </head>
    <body>
        <div class="main-layout">
            <div class="toolbar">
                <button
                    id="l-hist-btn"
                    class="btn btn-toggle"
                    onclick="toggleHistoryPanel()"
                >
                    ÂéÜÂè≤ËÆ∞ÂΩï
                </button>
                <div
                    style="
                        width: 1px;
                        height: 20px;
                        background: #ddd;
                        margin: 0 5px;
                    "
                ></div>
                <a
                    href="hanzi_explorer.html"
                    class="btn btn-toggle"
                    target="_blank"
                    >Ê±âÂ≠óÊµèËßàÂô®</a
                >
                <button
                    id="practice-mode-btn"
                    class="btn btn-toggle"
                    onclick="startPracticeMode()"
                >
                    ÁªÉ‰π†Ê®°Âºè
                </button>
                <button
                    id="exit-practice-mode-btn"
                    class="btn btn-toggle"
                    onclick="exitPracticeMode()"
                    style="
                        display: none;
                        background-color: #ff4d4f;
                        color: white;
                    "
                >
                    ÈÄÄÂá∫ÁªÉ‰π†
                </button>
                <a
                    href="https://github.com/123qweraz/webime"
                    target="_blank"
                    class="btn btn-github"
                    >GitHub Star</a
                >
                <button class="btn btn-toggle" onclick="openDictModal()">
                    ËØçÂÖ∏ËÆæÁΩÆ
                </button>
            </div>
            <div class="content-area">
                <div class="history-panel" id="historyPanel">
                    <div class="history-header">
                        <span>ËæìÂÖ•ÂéÜÂè≤</span>
                        <button
                            onclick="clearHistory()"
                            class="btn btn-toggle"
                            style="
                                margin-left: auto;
                                margin-right: 5px;
                                font-size: 10px;
                                padding: 4px 8px;
                            "
                        >
                            Ê∏ÖÁ©∫
                        </button>
                    </div>
                    <ul id="historyList" class="history-list"></ul>
                </div>
                <div class="resizer" id="left-resizer"></div>
                <div class="center-container">
                    <div class="output-card" id="output-card">
                        <div
                            id="output-area"
                            class="locked"
                            spellcheck="false"
                            oninput="syncFromEditor()"
                        ></div>
                        <div class="control-group">
                            <button
                                id="edit-mode-btn"
                                class="btn btn-toggle"
                                onclick="toggleEditMode()"
                            >
                                ÈîÅÂÆöÊ®°Âºè
                            </button>
                            <button
                                class="btn btn-toggle active"
                                style="background: #222"
                                onclick="archiveAndCopy()"
                            >
                                ÂΩíÊ°£Âπ∂Â§çÂà∂
                            </button>
                        </div>
                    </div>
                    <div id="practice-container">
                        <div id="card-left" class="practice-card-slot">
                            <div class="practice-card-content">
                                <div class="pinyin-display"></div>
                                <div class="hanzi-display"></div>
                            </div>
                        </div>
                        <div id="card-center" class="practice-card-slot">
                            <div class="practice-card-content">
                                <div class="pinyin-display"></div>
                                <div class="hanzi-display"></div>
                            </div>
                        </div>
                        <div id="card-right" class="practice-card-slot">
                            <div class="practice-card-content">
                                <div class="pinyin-display"></div>
                                <div class="hanzi-display"></div>
                            </div>
                        </div>
                        <div id="progress-container">
                            <div id="progress-bar"></div>
                        </div>
                    </div>
                    <div class="resizer-v" id="center-v-resizer"></div>
                    <div
                        class="input-card"
                        id="input-container"
                        onclick="focusHiddenInput()"
                    >
                        <div class="input-status-bar">
                            <div id="buffer-display"></div>
                            <div id="page-counter"></div>
                        </div>
                        <div id="main-candidates"></div>

                        <div id="practice-input-display"></div>
                        <!-- New element for visual buffer -->

                        <div id="correction-wrapper">
                            <input
                                type="text"
                                id="correction-input"
                                autocomplete="off"
                                placeholder="ËæìÂÖ•ÊãºÈü≥Áü≠ËØ≠ÔºåÁî®Á©∫Ê†ºÂàÜÈöîÔºåÂ¶Ç: ni hao"
                            />
                            <div class="correction-tip">
                                <span>ÊîØÊåÅÈïøÂè•ËæìÂÖ• (Á©∫Ê†ºÂàÜÈöî)</span>
                                <span>Enter ‰∏äÂ±è / Esc ÂèñÊ∂à</span>
                            </div>
                        </div>

                        <input
                            type="text"
                            id="hidden-input"
                            autocomplete="off"
                        />
                    </div>
                </div>
            </div>
        </div>
        <div id="loading-overlay">
            <div id="loading-spinner"></div>
            <p>Ê≠£Âú®ÂàùÂßãÂåñËæìÂÖ•Ê≥ï...</p>
        </div>
        <div id="toast"></div>

        <div id="dict-modal" class="modal-overlay" style="display: none">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>ËØçÂÖ∏ÁÆ°ÁêÜ</h3>
                    <button onclick="closeDictModal()">‚úï</button>
                </div>
                <div class="modal-body">
                    <div class="import-section">
                        <input
                            type="file"
                            id="dict-file-input"
                            style="display: none"
                            onchange="handleImport(this)"
                        />
                        <button
                            class="btn"
                            onclick="
                                document
                                    .getElementById('dict-file-input')
                                    .click()
                            "
                        >
                            ÂØºÂÖ•Êñ∞ËØçÂÖ∏ (.json)
                        </button>
                    </div>

                    <div class="modal-controls">
                        <button
                            class="btn btn-toggle"
                            onclick="sortDictsByDefaultOrder()"
                        >
                            ‰∏≠Êñá
                        </button>
                    </div>

                    <div class="dict-sections">
                        <h4>Â∑≤ÂêØÁî® (ÊãñÊãΩÊéíÂ∫è)</h4>
                        <div id="modal-active-list" class="dict-list"></div>

                        <h4>Êú™ÂêØÁî®</h4>
                        <div id="modal-inactive-list" class="dict-list"></div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // --- Practice Mode Functions ---

            async function initPracticeModeData() {
                const practiceDict = allDicts.find(
                    (d) => d.name === PRACTICE_DICT_NAME,
                );
                if (!practiceDict) {
                    showErrorMessage(
                        `ÁªÉ‰π†ËØçÂÖ∏ "${PRACTICE_DICT_NAME}" Êú™ÊâæÂà∞!`,
                    );
                    return false;
                }

                // If the content is not fetched yet, fetch it.
                // This is a fallback, as dicts should be loaded at startup.
                if (!practiceDict.fetchedContent) {
                    try {
                        const response = await fetch(practiceDict.path);
                        if (!response.ok)
                            throw new Error(
                                `Network response was not ok for ${practiceDict.path}`,
                            );
                        practiceDict.fetchedContent = await response.json();
                    } catch (error) {
                        showErrorMessage(`Âä†ËΩΩÁªÉ‰π†ËØçÂÖ∏Â§±Ë¥•: ${error.message}`);
                        return false;
                    }
                }

                const dictData = practiceDict.fetchedContent;
                practiceWords = [];
                for (const pinyin in dictData) {
                    dictData[pinyin].forEach((hanzi) => {
                        practiceWords.push({ pinyin, hanzi });
                    });
                }

                // Shuffle the words
                for (let i = practiceWords.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [practiceWords[i], practiceWords[j]] = [
                        practiceWords[j],
                        practiceWords[i],
                    ];
                }

                console.log(
                    `Practice mode ready with ${practiceWords.length} words.`,
                );
                return true;
            }

            async function startPracticeMode() {
                if (practiceWords.length === 0) {
                    showLoadingMessage("ÂáÜÂ§áÁªÉ‰π†...");
                    const success = await initPracticeModeData();
                    hideLoadingMessage();
                    if (!success) return;
                }

                setState(InputState.PRACTICE);

                // Load progress from localStorage or start from 0
                const savedIndex = localStorage.getItem(PRACTICE_PROGRESS_KEY);
                currentPracticeWordIndex = savedIndex
                    ? parseInt(savedIndex, 10)
                    : 0;

                // Update progress bar to reflect loaded progress
                const progressBar = document.getElementById("progress-bar");
                const progress =
                    practiceWords.length > 0
                        ? (currentPracticeWordIndex / practiceWords.length) *
                          100
                        : 0;
                progressBar.style.width = `${progress}%`;

                console.log("Starting practice mode UI...");
                document.getElementById("output-card").style.display = "none";
                document.getElementById("practice-container").style.display =
                    "flex"; // Show practice container

                // Initialize card elements
                cardLeft = document.getElementById("card-left");
                cardCenter = document.getElementById("card-center");
                cardRight = document.getElementById("card-right");
                practiceCards = [cardLeft, cardCenter, cardRight];

                currentInputDisplay = document.getElementById(
                    PRACTICE_MODE_INPUT_ID,
                );
                currentInputDisplay.innerHTML = ""; // Clear visual buffer

                // Toggle visibility of buttons in toolbar
                document.getElementById("practice-mode-btn").style.display =
                    "none";
                document.getElementById(
                    "exit-practice-mode-btn",
                ).style.display = "flex";

                // Initial setup of cards
                loadCards(); // New function to load initial cards
                focusHiddenInput();
            }

            function exitPracticeMode() {
                console.log("Exiting practice mode...");
                isPracticeAnimating = false; // Reset animation flag
                setState(InputState.NORMAL);

                document.getElementById("output-card").style.display = "flex";
                document.getElementById("practice-container").style.display =
                    "none"; // Hide practice container

                // Clear and reset all practice cards
                practiceCards.forEach((card) => {
                    card.classList.remove("visible", "current", "incorrect");
                    card.querySelector(".pinyin-display").textContent = "";
                    card.querySelector(".hanzi-display").textContent = "";
                });
                completedRightCardWord = null; // Clear completed word

                // Clear input display
                if (currentInputDisplay) {
                    currentInputDisplay.innerHTML = "";
                }

                // Toggle visibility of buttons in toolbar
                document.getElementById("practice-mode-btn").style.display =
                    "flex";
                document.getElementById(
                    "exit-practice-mode-btn",
                ).style.display = "none";

                // Also reset progress bar to 0 when exiting
                document.getElementById("progress-bar").style.width = "0%";
            }
            // New function to load initial cards
            function loadCards() {
                // Clear any existing content and classes
                practiceCards.forEach((card) => {
                    card.classList.remove("visible", "current", "incorrect");
                    card.querySelector(".pinyin-display").textContent = "";
                    card.querySelector(".hanzi-display").textContent = "";
                });

                // Load the first word into the center card
                if (currentPracticeWordIndex < practiceWords.length) {
                    const word = practiceWords[currentPracticeWordIndex];
                    cardCenter.querySelector(".hanzi-display").textContent =
                        word.hanzi;
                    cardCenter.classList.add("visible", "current");
                } else {
                    // No words left, exit practice
                    exitPracticeMode();
                    return;
                }

                // If there's a next word, load it into the left card (upcoming)
                if (currentPracticeWordIndex + 1 < practiceWords.length) {
                    const nextWord =
                        practiceWords[currentPracticeWordIndex + 1];
                    cardLeft.querySelector(".hanzi-display").textContent =
                        nextWord.hanzi;
                    cardLeft.classList.add("visible");
                }
                // Right card is initially empty
            }

            function showNextPracticeWord() {
                if (currentPracticeWordIndex >= practiceWords.length) {
                    alert("ÁªÉ‰π†ÂÆåÊàê! üéâ");
                    localStorage.removeItem(PRACTICE_PROGRESS_KEY);
                    exitPracticeMode();
                    return;
                }

                // Content for the three cards
                const wordOnCenter = practiceWords[currentPracticeWordIndex];
                const wordOnLeft = practiceWords[currentPracticeWordIndex + 1];
                const wordOnRight = practiceWords[currentPracticeWordIndex - 1]; // This was the previously completed word

                // Update cardRight (previously completed word)
                if (wordOnRight) {
                    cardRight.querySelector(".hanzi-display").textContent =
                        wordOnRight.hanzi;
                    cardRight.querySelector(".pinyin-display").textContent =
                        wordOnRight.pinyin.split("").join(" ");
                    cardRight.classList.add("visible");
                } else {
                    cardRight.classList.remove("visible");
                    cardRight.querySelector(".hanzi-display").textContent = "";
                    cardRight.querySelector(".pinyin-display").textContent = "";
                }

                // Update cardCenter (current word to practice)
                if (wordOnCenter) {
                    cardCenter.querySelector(".hanzi-display").textContent =
                        wordOnCenter.hanzi;
                    cardCenter.querySelector(".pinyin-display").textContent =
                        ""; // No pinyin for current card
                    cardCenter.classList.add("visible", "current");
                    cardCenter.classList.remove("incorrect");
                } else {
                    cardCenter.classList.remove(
                        "visible",
                        "current",
                        "incorrect",
                    );
                    cardCenter.querySelector(".hanzi-display").textContent = "";
                    cardCenter.querySelector(".pinyin-display").textContent =
                        "";
                }

                // Update cardLeft (next upcoming word)
                if (wordOnLeft) {
                    cardLeft.querySelector(".hanzi-display").textContent =
                        wordOnLeft.hanzi;
                    cardLeft.querySelector(".pinyin-display").textContent = "";
                    cardLeft.classList.add("visible");
                } else {
                    cardLeft.classList.remove("visible");
                    cardLeft.querySelector(".hanzi-display").textContent = "";
                    cardLeft.querySelector(".pinyin-display").textContent = "";
                }

                // Clear input
                setBuffer("");
                update();
                currentInputDisplay.innerHTML = "";
                focusHiddenInput();
            }

            // Dictionary Modal Functions
            function openDictModal() {
                document.getElementById("dict-modal").style.display = "flex";
                renderModalDicts(); // Render dictionaries when modal opens
            }

            function closeDictModal() {
                document.getElementById("dict-modal").style.display = "none";
            }

            function renderModalDicts() {
                const activeList = document.getElementById("modal-active-list");
                const inactiveList = document.getElementById(
                    "modal-inactive-list",
                );
                activeList.innerHTML = "";
                inactiveList.innerHTML = "";

                allDicts.forEach((dict, index) => {
                    const dictCard = document.createElement("div");
                    dictCard.className = `dict-card ${!dict.enabled ? "disabled" : ""}`;
                    dictCard.setAttribute("data-index", index);
                    dictCard.setAttribute("draggable", "true"); // Make draggable
                    dictCard.setAttribute("tabindex", "0"); // Make focusable for keyboard navigation

                    dictCard.addEventListener("dragstart", (e) => {
                        draggedDictIndex = index;
                        e.dataTransfer.effectAllowed = "move";
                        e.dataTransfer.setData("text/plain", index); // Set data for Firefox
                        setTimeout(() => (dictCard.style.opacity = "0.5"), 0); // Hide dragged item
                    });

                    dictCard.addEventListener("dragover", (e) => {
                        e.preventDefault(); // Allow drop
                        const targetCard = e.currentTarget;
                        if (
                            draggedDictIndex !== null &&
                            draggedDictIndex !== index
                        ) {
                            const bounding = targetCard.getBoundingClientRect();
                            const offset = bounding.y + bounding.height / 2;
                            if (e.clientY < offset) {
                                targetCard.style.borderTop =
                                    "2px solid var(--primary)";
                                targetCard.style.borderBottom = "";
                            } else {
                                targetCard.style.borderBottom =
                                    "2px solid var(--primary)";
                                targetCard.style.borderTop = "";
                            }
                        }
                    });

                    dictCard.addEventListener("dragleave", (e) => {
                        e.currentTarget.style.borderTop = "";
                        e.currentTarget.style.borderBottom = "";
                    });

                    dictCard.addEventListener("drop", (e) => {
                        e.preventDefault();
                        e.currentTarget.style.borderTop = "";
                        e.currentTarget.style.borderBottom = "";
                        if (
                            draggedDictIndex !== null &&
                            draggedDictIndex !== index
                        ) {
                            const droppedOnIndex = index;
                            const isBefore =
                                e.clientY <
                                e.currentTarget.getBoundingClientRect().y +
                                    e.currentTarget.getBoundingClientRect()
                                        .height /
                                        2;
                            handleDictDrop(
                                draggedDictIndex,
                                droppedOnIndex,
                                isBefore,
                            );
                        }
                    });

                    dictCard.addEventListener("dragend", (e) => {
                        e.target.style.opacity = "1"; // Restore opacity
                        draggedDictIndex = null;
                        document
                            .querySelectorAll(".dict-card")
                            .forEach((card) => {
                                card.style.borderTop = "";
                                card.style.borderBottom = "";
                            });
                    });

                    dictCard.addEventListener("keydown", (e) =>
                        handleDictCardKeyDown(index, e),
                    );

                    dictCard.innerHTML = `
                        <span class="dict-card-name">${dict.name} (${dict.wordCount || 0} ËØç)</span>
                        <div class="dict-card-actions">
                            <button class="btn btn-sm move-up-btn" onclick="moveDictUp(${index})" ${index === 0 ? "disabled" : ""}>‚Üë</button>
                            <button class="btn btn-sm move-down-btn" onclick="moveDictDown(${index})" ${index === allDicts.length - 1 ? "disabled" : ""}>‚Üì</button>
                            <button class="btn btn-sm toggle-btn ${dict.enabled ? "toggle-on" : "toggle-off"}" onclick="toggleDictStatus(${index})">
                                ${dict.enabled ? "Á¶ÅÁî®" : "ÂêØÁî®"}
                            </button>
                            ${dict.type !== "built-in" ? `<button class="btn btn-sm delete-btn" onclick="deleteDict(${index})">Âà†Èô§</button>` : ""}
                        </div>
                    `;

                    if (dict.enabled) {
                        activeList.appendChild(dictCard);
                    } else {
                        inactiveList.appendChild(dictCard);
                    }
                });
            }

            async function sortDictsByDefaultOrder() {
                const desiredOrder = [
                    "‰∏ÄÁ∫ßÂ≠ó",
                    "ËØçÁªÑËØçÂÖ∏",
                    "‰∫åÁ∫ßÂ≠ó",
                    "‰∏âÁ∫ßÂ≠ó",
                    "ÂõõÂ≠óËØç",
                ];

                // First, enable all dictionaries that are part of the desired order
                allDicts.forEach((dict) => {
                    if (desiredOrder.includes(dict.name)) {
                        dict.enabled = true;
                    }
                });

                allDicts.sort((a, b) => {
                    const indexA = desiredOrder.indexOf(a.name);
                    const indexB = desiredOrder.indexOf(b.name);

                    // If both are in desiredOrder, sort by their index
                    if (indexA !== -1 && indexB !== -1) {
                        return indexA - indexB;
                    }
                    // If only 'a' is in desiredOrder, 'a' comes first
                    if (indexA !== -1) {
                        return -1;
                    }
                    // If only 'b' is in desiredOrder, 'b' comes first
                    if (indexB !== -1) {
                        return 1;
                    }
                    // If neither is in desiredOrder, maintain current relative order (or sort by name as a fallback)
                    return a.name.localeCompare(b.name);
                });

                saveDictConfig();
                await loadAllDicts();
                renderModalDicts();
                showToast("‰∏≠ÊñáËØçÂÖ∏Â∑≤ÂêØÁî®Âπ∂ÊéíÂ∫è", "info");
            }

            let draggedDictIndex = null; // Global variable to store the index of the dictionary being dragged

            async function handleDictDrop(
                draggedIndex,
                droppedOnIndex,
                isBefore,
            ) {
                // If dragged and dropped on the same item, or if the indices are invalid, do nothing
                if (
                    draggedIndex === droppedOnIndex ||
                    draggedIndex < 0 ||
                    droppedOnIndex < 0 ||
                    draggedIndex >= allDicts.length ||
                    droppedOnIndex >= allDicts.length
                ) {
                    return;
                }

                const [movedDict] = allDicts.splice(draggedIndex, 1);
                let targetIndex = droppedOnIndex;

                if (draggedIndex < droppedOnIndex) {
                    // Item was dragged downwards
                    if (isBefore) {
                        // Dropped before the target, so new index is target - 1
                        targetIndex = droppedOnIndex - 1;
                    } else {
                        // Dropped after the target, new index is target
                        targetIndex = droppedOnIndex;
                    }
                } else {
                    // Item was dragged upwards
                    if (isBefore) {
                        // Dropped before the target, new index is target
                        targetIndex = droppedOnIndex;
                    } else {
                        // Dropped after the target, new index is target + 1
                        targetIndex = droppedOnIndex + 1;
                    }
                }

                // Ensure targetIndex is within valid bounds
                targetIndex = Math.max(
                    0,
                    Math.min(targetIndex, allDicts.length),
                );

                allDicts.splice(targetIndex, 0, movedDict);
                saveDictConfig();
                await loadAllDicts();
                renderModalDicts();
                showToast(`ËØçÂÖ∏ "${movedDict.name}" Â∑≤ÁßªÂä®`, "info");
            }

            async function handleDictCardKeyDown(index, event) {
                if (event.key === "ArrowUp") {
                    event.preventDefault();
                    if (index > 0) {
                        const [movedDict] = allDicts.splice(index, 1);
                        allDicts.splice(index - 1, 0, movedDict);
                        saveDictConfig();
                        await loadAllDicts();
                        renderModalDicts();
                        // Refocus the moved element
                        requestAnimationFrame(() => {
                            const newCard = document.querySelector(
                                `.dict-card[data-index="${index - 1}"]`,
                            );
                            if (newCard) newCard.focus();
                        });
                        showToast(`ËØçÂÖ∏ "${movedDict.name}" ‰∏äÁßª`, "info");
                    }
                } else if (event.key === "ArrowDown") {
                    event.preventDefault();
                    if (index < allDicts.length - 1) {
                        const [movedDict] = allDicts.splice(index, 1);
                        allDicts.splice(index + 1, 0, movedDict);
                        saveDictConfig();
                        await loadAllDicts();
                        renderModalDicts();
                        // Refocus the moved element
                        requestAnimationFrame(() => {
                            const newCard = document.querySelector(
                                `.dict-card[data-index="${index + 1}"]`,
                            );
                            if (newCard) newCard.focus();
                        });
                        showToast(`ËØçÂÖ∏ "${movedDict.name}" ‰∏ãÁßª`, "info");
                    }
                }
            }
            async function toggleDictStatus(index) {
                if (allDicts[index]) {
                    allDicts[index].enabled = !allDicts[index].enabled;
                    saveDictConfig(); // Save changes to localStorage
                    await loadAllDicts(); // Reload Trie to reflect changes
                    renderModalDicts(); // Re-render modal to show updated status
                }
            }

            async function moveDictUp(index) {
                if (index > 0) {
                    const [movedDict] = allDicts.splice(index, 1); // Remove from current position
                    allDicts.splice(index - 1, 0, movedDict); // Insert at new position
                    saveDictConfig(); // Save changes
                    await loadAllDicts(); // Reload Trie
                    renderModalDicts(); // Re-render modal
                }
            }

            async function moveDictDown(index) {
                if (index < allDicts.length - 1) {
                    const [movedDict] = allDicts.splice(index, 1); // Remove from current position
                    allDicts.splice(index + 1, 0, movedDict); // Insert at new position
                    saveDictConfig(); // Save changes
                    await loadAllDicts(); // Reload Trie
                    renderModalDicts(); // Re-render modal
                }
            }

            async function deleteDict(index) {
                if (allDicts[index].type === "built-in") {
                    showToast("Êó†Ê≥ïÂà†Èô§ÂÜÖÁΩÆËØçÂÖ∏", "warning");
                    return;
                }
                if (
                    allDicts[index] &&
                    confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ËØçÂÖ∏ "${allDicts[index].name}" ÂêóÔºü`)
                ) {
                    allDicts.splice(index, 1); // Remove from array
                    saveDictConfig(); // Save changes
                    await loadAllDicts(); // Reload Trie
                    renderModalDicts(); // Re-render modal
                }
            }

            // Function for handling dictionary import from the modal
            /**
             * Êõ¥Êñ∞ÂéÜÂè≤ËÆ∞ÂΩïUIÊòæÁ§∫
             * @param {Array} historyItems - ÂéÜÂè≤ËÆ∞ÂΩïÊù°ÁõÆÊï∞ÁªÑ
             */
            function updateHistoryUI(historyItems) {
                try {
                    const historyList = document.getElementById("historyList");
                    if (!historyList) {
                        console.warn("ÂéÜÂè≤ËÆ∞ÂΩïÂÆπÂô®ÂÖÉÁ¥†Êú™ÊâæÂà∞");
                        return;
                    }

                    // Ê∏ÖÁ©∫Áé∞ÊúâÂÜÖÂÆπ
                    historyList.innerHTML = "";

                    // Â¶ÇÊûúÊ≤°ÊúâÂéÜÂè≤ËÆ∞ÂΩïÔºåÊòæÁ§∫ÊèêÁ§∫
                    if (!historyItems || historyItems.length === 0) {
                        const emptyItem = document.createElement("li");
                        emptyItem.className = "history-item empty";
                        emptyItem.textContent = "ÊöÇÊó†ËæìÂÖ•ÂéÜÂè≤";
                        historyList.appendChild(emptyItem);
                        return;
                    }

                    // ÊòæÁ§∫ÊúÄËøëÁöÑÂéÜÂè≤ËÆ∞ÂΩïÔºàÊúÄÂ§ö20Êù°Ôºâ
                    const recentItems = historyItems.slice(0, 20);

                    recentItems.forEach((item, index) => {
                        const listItem = document.createElement("li");
                        listItem.className = "history-item";

                        const timeSpan = document.createElement("span");
                        timeSpan.className = "history-time";

                        if (item.timestamp) {
                            const date = new Date(item.timestamp);
                            timeSpan.textContent = date.toLocaleTimeString([], {
                                hour: "2-digit",
                                minute: "2-digit",
                            });
                        } else {
                            timeSpan.textContent = "ÂàöÂàö";
                        }

                        const textSpan = document.createElement("span");
                        textSpan.className = "history-text";
                        textSpan.textContent = item.text || item;

                        // Delete button
                        const deleteButton = document.createElement("button");
                        deleteButton.textContent = "√ó";
                        deleteButton.className = "history-delete-btn";
                        deleteButton.onclick = (event) => {
                            event.stopPropagation(); // Prevent listItem click event
                            deleteHistoryItem(index);
                        };

                        listItem.appendChild(timeSpan);
                        listItem.appendChild(textSpan);
                        listItem.appendChild(deleteButton);

                        // Clicking history item to fill input
                        listItem.addEventListener("click", () => {
                            const inputElement =
                                document.getElementById("hidden-input");
                            if (
                                inputElement &&
                                inputElement.value !== undefined
                            ) {
                                inputElement.value = item.text || item;
                                const inputEvent = new Event("input", {
                                    bubbles: true,
                                });
                                inputElement.dispatchEvent(inputEvent);
                            }
                        });

                        historyList.appendChild(listItem);
                    });
                } catch (error) {
                    console.error("Êõ¥Êñ∞ÂéÜÂè≤ËÆ∞ÂΩïUIÂ§±Ë¥•:", error);
                }
            }

            /**
             * ÊòæÁ§∫ToastÊèêÁ§∫Ê∂àÊÅØ
             * @param {string} message - Ë¶ÅÊòæÁ§∫ÁöÑÊ∂àÊÅØ
             * @param {string} type - Ê∂àÊÅØÁ±ªÂûãÔºö'success' | 'error' | 'info' | 'warning'
             * @param {number} duration - ÊòæÁ§∫ÊåÅÁª≠Êó∂Èó¥ÔºàÊØ´ÁßíÔºâÔºåÈªòËÆ§3000ms
             */
            function showToast(message, type = "info", duration = 3000) {
                try {
                    // ÁßªÈô§Áé∞ÊúâÁöÑToast
                    const existingToast =
                        document.getElementById("inputMethodToast");
                    if (existingToast) {
                        existingToast.remove();
                    }

                    // ÂàõÂª∫ToastÂÖÉÁ¥†
                    const toast = document.createElement("div");
                    toast.id = "inputMethodToast";
                    toast.className = `input-method-toast toast-${type}`;

                    // ËÆæÁΩÆToastÂÜÖÂÆπ
                    const toastContent = document.createElement("div");
                    toastContent.className = "toast-content";
                    toastContent.textContent = message;

                    // Ê∑ªÂä†ÂõæÊ†áÔºàÂèØÈÄâÔºâ
                    const toastIcon = document.createElement("span");
                    toastIcon.className = "toast-icon";

                    // Ê†πÊçÆÁ±ªÂûãËÆæÁΩÆ‰∏çÂêåÁöÑÂõæÊ†á
                    const iconMap = {
                        success: "‚úì",
                        error: "‚úó",
                        warning: "‚ö†",
                        info: "‚Ñπ",
                    };
                    toastIcon.textContent = iconMap[type] || iconMap.info;

                    // ÁªÑË£ÖToast
                    toast.appendChild(toastIcon);
                    toast.appendChild(toastContent);

                    // Ê∑ªÂä†ÂÖ≥Èó≠ÊåâÈíÆ
                    const closeBtn = document.createElement("button");
                    closeBtn.className = "toast-close";
                    closeBtn.innerHTML = "&times;";
                    closeBtn.onclick = () => toast.remove();
                    toast.appendChild(closeBtn);

                    // Ê∑ªÂä†Âà∞È°µÈù¢
                    document.body.appendChild(toast);

                    // Ê∑ªÂä†ÊòæÁ§∫Âä®Áîª
                    setTimeout(() => {
                        toast.classList.add("show");
                    }, 10);

                    // Ëá™Âä®Ê∂àÂ§±
                    if (duration > 0) {
                        setTimeout(() => {
                            if (toast.parentNode) {
                                toast.classList.remove("show");
                                setTimeout(() => {
                                    if (toast.parentNode) {
                                        toast.remove();
                                    }
                                }, 300); // Á≠âÂæÖÊ∑°Âá∫Âä®ÁîªÂÆåÊàê
                            }
                        }, duration);
                    }
                } catch (error) {
                    console.error("ÊòæÁ§∫ToastÂ§±Ë¥•:", error);
                    // ÈôçÁ∫ßÊñπÊ°àÔºö‰ΩøÁî®alert
                    alert(`${type.toUpperCase()}: ${message}`);
                }
            }

            /**
             * ÊòæÁ§∫ÈîôËØØÊ∂àÊÅØÔºàÂåÖË£ÖÂáΩÊï∞Ôºâ
             * @param {string} message - ÈîôËØØÊ∂àÊÅØ
             * @param {Error} error - ÈîôËØØÂØπË±°ÔºàÂèØÈÄâÔºâ
             */
            function showErrorMessage(message, error = null) {
                console.error("ËæìÂÖ•Ê≥ïÈîôËØØ:", message, error);

                // ‰ΩøÁî®showToastÊòæÁ§∫ÈîôËØØÊ∂àÊÅØ
                showToast(
                    `${message}${error ? ": " + error.message : ""}`,
                    "error",
                    5000,
                );

                // ÂêåÊó∂Âú®ËæìÂá∫Âå∫ÂüüÊòæÁ§∫ÈîôËØØ
                const outputArea = document.getElementById("output-area"); // Correct ID
                if (outputArea) {
                    const errorDiv = document.createElement("div");
                    errorDiv.className = "error-message";
                    errorDiv.innerHTML = `
                        <strong>ÈîôËØØ:</strong> ${message}
                        ${error ? "<br><small>" + error.message + "</small>" : ""}
                    `;
                    outputArea.appendChild(errorDiv);
                }
            }

            /**
             * ÊòæÁ§∫Âä†ËΩΩÊ∂àÊÅØ
             * @param {string} message - Ë¶ÅÊòæÁ§∫ÁöÑÂä†ËΩΩÊ∂àÊÅØ
             */
            function showLoadingMessage(message) {
                try {
                    const loadingOverlay =
                        document.getElementById("loading-overlay");
                    const messageElement = loadingOverlay.querySelector("p");

                    if (message) {
                        messageElement.textContent = message;
                    }

                    loadingOverlay.style.display = "flex";
                } catch (error) {
                    console.error("ÊòæÁ§∫Âä†ËΩΩÊ∂àÊÅØÂ§±Ë¥•:", error);
                }
            }

            /**
             * ÈöêËóèÂä†ËΩΩÊ∂àÊÅØ
             */
            function hideLoadingMessage() {
                try {
                    const loadingOverlay =
                        document.getElementById("loading-overlay");
                    loadingOverlay.style.display = "none";
                } catch (error) {
                    console.error("ÈöêËóèÂä†ËΩΩÊ∂àÊÅØÂ§±Ë¥•:", error);
                }
            }

            /**
             * ËÅöÁÑ¶Âà∞ÈöêËóèËæìÂÖ•Ê°Ü
             */
            function focusHiddenInput() {
                try {
                    const hInput = document.getElementById("hidden-input");
                    if (hInput) {
                        hInput.focus();
                    }
                } catch (error) {
                    console.error("ËÅöÁÑ¶ÈöêËóèËæìÂÖ•Ê°ÜÂ§±Ë¥•:", error);
                }
            }

            /**
             * ËÆæÁΩÆËæìÂÖ•ÁºìÂÜ≤Âå∫
             * @param {string} value - ÁºìÂÜ≤Âå∫ÂÄº
             */
            function setBuffer(value) {
                buffer = value;
                const hInput = document.getElementById("hidden-input");
                if (hInput) {
                    hInput.value = value;
                }
            }

            /**
             * Â∞ÜÊãºÈü≥Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫Ê±âÂ≠ó„ÄÇ
             * ÁõÆÂâçÂè™ÂèñÊØè‰∏™ÊãºÈü≥ÁöÑÁ¨¨‰∏Ä‰∏™ÂÄôÈÄâËØç„ÄÇ
             * @param {string} pinyinString - ‰ª•Á©∫Ê†ºÂàÜÈöîÁöÑÊãºÈü≥Â≠óÁ¨¶‰∏≤ (e.g., "ni hao")
             * @returns {string} ËΩ¨Êç¢ÂêéÁöÑÊ±âÂ≠óÂ≠óÁ¨¶‰∏≤
             */
            function convertPinyinToHanzi(pinyinString) {
                const pinyinSegments = pinyinString.trim().split(/\s+/);
                let hanziResult = [];

                for (const segment of pinyinSegments) {
                    if (!segment) continue;

                    const node = DB.getNode(segment.toLowerCase());
                    let foundHanzi = null;

                    if (node && node.values.length > 0) {
                        // Assuming the first value is the most relevant or a good default
                        // In a more advanced IME, this would involve ranking or user selection
                        foundHanzi = node.values[0].char || node.values[0];
                    }

                    hanziResult.push(foundHanzi || segment); // Fallback to pinyin if no Hanzi found
                }
                return hanziResult.join("");
            }

            /**
             * ËøõÂÖ•‰øÆÊ≠£Ê®°Âºè
             */
            function enterCorrectionMode() {
                setState(InputState.CORRECTION);
                correctionWrapper.style.display = "block";
                correctionInput.value = buffer; // Sync In: Fill with current buffer
                correctionInput.focus();
            }

            /**
             * ÈÄÄÂá∫‰øÆÊ≠£Ê®°Âºè
             * @param {string} action - ÈÄÄÂá∫Âä®‰ΩúÁ±ªÂûã
             */
            function exitCorrectionMode(action) {
                if (action === "convert_sentence") {
                    const pinyinPhrase = correctionInput.value.trim();
                    if (pinyinPhrase) {
                        const convertedHanzi =
                            convertPinyinToHanzi(pinyinPhrase);
                        committed += convertedHanzi;
                    }
                    // Clear the main buffer after committing from correction mode
                    setBuffer("");
                } else if (action === "sync_out_buffer") {
                    // New logic for sync-out
                    const correctedText = correctionInput.value.trim();
                    setBuffer(correctedText); // Update global buffer and hInput.value
                    pageIndex = 0; // Reset page index
                    setTimeout(() => update(), 0); // Add a small delay for UI refresh
                    // Removed 'return;' here to allow subsequent state changes
                }

                setState(InputState.NORMAL);
                correctionWrapper.style.display = "none";
                update();
            }

            /**
             * ÂàáÊç¢ÁºñËæëÊ®°Âºè
             */
            function toggleEditMode() {
                const isEditing = currentState === InputState.EDIT;
                setState(isEditing ? InputState.NORMAL : InputState.EDIT);

                const outputCard = document.getElementById("output-card");
                const editBtn = document.getElementById("edit-mode-btn");

                if (isEditing) {
                    outputCard.classList.remove("editing");
                    outputArea.classList.add("locked");
                    outputArea.contentEditable = false; // Disable contenteditable
                    editBtn.textContent = "ÈîÅÂÆöÊ®°Âºè";
                } else {
                    outputCard.classList.add("editing");
                    outputArea.classList.remove("locked");
                    outputArea.contentEditable = true; // Enable contenteditable
                    editBtn.textContent = "ÁºñËæëÊ®°Âºè";
                }
            }

            function archiveAndCopy() {
                try {
                    if (committed.trim()) {
                        // History is now managed by resetInput()

                        // No need to add to history here explicitly for committed text

                        // Just copy to clipboard and clear committed.

                        // Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø

                        navigator.clipboard

                            .writeText(committed)

                            .then(() => {
                                committed = "";

                                update();
                            })

                            .catch((err) => {
                                console.error("Â§çÂà∂Â§±Ë¥•:", err);

                                showToast("Â§çÂà∂Â§±Ë¥•", "error");
                            });
                    } else {
                        showToast("Ê≤°ÊúâÂÜÖÂÆπÂèØÂ§çÂà∂", "warning");
                    }
                } catch (error) {
                    console.error("ÂΩíÊ°£Â§çÂà∂Â§±Ë¥•:", error);

                    showToast("Êìç‰ΩúÂ§±Ë¥•", "error");
                }
            }

            /**
             * ‰ªéÁºñËæëÂô®ÂêåÊ≠•ÂÜÖÂÆπ
             */
            function syncFromEditor() {
                if (currentState === InputState.EDIT) {
                    committed = outputArea.textContent || "";
                }
            }

            /**
             * ÂàáÊç¢ÂéÜÂè≤ËÆ∞ÂΩïÈù¢Êùø
             */
            function toggleHistoryPanel() {
                const historyPanel = document.getElementById("historyPanel");
                const isVisible =
                    window.getComputedStyle(historyPanel).display === "flex";
                const newVisibility = !isVisible;
                historyPanel.style.display = newVisibility ? "flex" : "none";

                const histBtn = document.getElementById("l-hist-btn");
                histBtn.classList.toggle("active", newVisibility);

                // Update and save the setting
                settings.history = newVisibility;
                saveSettings();
            }

            /**
             * Ê∏ÖÁ©∫ÊâÄÊúâÂéÜÂè≤ËÆ∞ÂΩï
             */
            function clearHistory() {
                if (confirm("Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâËæìÂÖ•ÂéÜÂè≤ÂêóÔºü")) {
                    HISTORY = []; // Clear the in-memory array
                    saveHistory(); // Save empty array and update UI
                }
            }

            /**
             * Âà†Èô§Âçï‰∏™ÂéÜÂè≤ËÆ∞ÂΩïÈ°π
             * @param {number} index - Ë¶ÅÂà†Èô§È°πÁöÑÁ¥¢Âºï
             */
            function deleteHistoryItem(index) {
                if (index >= 0 && index < HISTORY.length) {
                    HISTORY.splice(index, 1); // Remove item from array
                    saveHistory(); // Update localStorage and Refresh UI
                }
            }

            // New function for saving history
            function saveHistory() {
                // Limit history to a certain number of items, e.g., 50
                const maxHistoryItems = 50;
                if (HISTORY.length > maxHistoryItems) {
                    HISTORY = HISTORY.slice(0, maxHistoryItems);
                }
                localStorage.setItem(
                    "ime_history_v18",
                    JSON.stringify(HISTORY),
                );
                updateHistoryUI(HISTORY);
            }

            /**
             * ‰øùÂ≠òËÆæÁΩÆ
             */
            function saveSettings() {
                localStorage.setItem("ime_settings", JSON.stringify(settings));
                console.log("Settings saved:", settings); // Debugging line
            }

            // Function for handling dictionary import from the modal
            async function handleImport(input) {
                const file = input.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const content = JSON.parse(e.target.result);
                        const newDict = {
                            name: file.name.replace(".json", ""),
                            enabled: true,
                            type: "user",
                            // Assuming the dictionary content itself is stored for later Trie rebuild
                            // Use 'content' property as previously defined in allDicts structure
                            content: JSON.stringify(content),
                        };
                        allDicts.push(newDict);
                        saveDictConfig(); // Uses saveDictConfig which handles localStorage and saveSettings

                        await loadAllDicts(); // Rebuild Trie with new dict
                        renderModalDicts(); // Re-render modal to show new dict
                        showToast(`Â∑≤ÂØºÂÖ•ËØçÂÖ∏: ${newDict.name}`, "info"); // Use info toast for feedback
                    } catch (error) {
                        console.error("ÂØºÂÖ•ËØçÂÖ∏Â§±Ë¥•:", error);
                        showToast("ÂØºÂÖ•Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Êñá‰ª∂Ê†ºÂºè", "error");
                    }
                };
                reader.readAsText(file);
                input.value = ""; // Reset file input
            }

            // --- End Missing function definitions ---

            // --- Init functions ---
            async function initInputHandler() {
                // Attach event listeners for hInput, correctionInput
                // Keep this minimal, actual logic handled by keydown/input listeners
                hInput.addEventListener("keydown", handleKeyDown);
                hInput.addEventListener("input", handleInput);
                correctionInput.addEventListener(
                    "keydown",
                    handleCorrectionKeyDown,
                );
            }

            function initUI() {
                // Initialize UI elements like outputArea, bufferDisplay, mainCandidates
                // Most of this is already done by direct DOM access, but this function
                // serves as a placeholder for more complex UI setup.
            }

            function initEventListeners() {
                // Global event listeners
                document.addEventListener("keydown", handleGlobalKeyDown);
                document.addEventListener("click", handleGlobalClick);
                document.addEventListener(
                    "visibilitychange",
                    handleVisibilityChange,
                );
            }
            // --- End Init functions ---

            const InputState = {
                NORMAL: "normal",
                PRACTICE: "practice",
                EDIT: "edit",
                CORRECTION: "correction",
                TAB: "tab",
            };

            let currentState = InputState.NORMAL;
            function setState(newState) {
                currentState = newState;
                // Manage 'locked' class on outputArea
                if (outputArea) {
                    if (currentState === InputState.NORMAL) {
                        outputArea.classList.add("locked");
                    } else {
                        outputArea.classList.remove("locked");
                    }
                }
                updateFocus();
            }

            function updateFocus() {
                if (currentState === InputState.EDIT) {
                    outputArea.focus();
                } else if (currentState === InputState.CORRECTION) {
                    correctionInput.focus();
                } else {
                    hInput.focus();
                }
            }

            const PUNCS = {
                ",": "Ôºå",
                ".": "„ÄÇ",
                "!": "ÔºÅ",
                "?": "Ôºü",
                ";": "Ôºõ",
                ":": "Ôºö",
                "(": "Ôºà",
                ")": "Ôºâ",
                "[": "„Äê",
                "]": "„Äë",
            };

            const NON_PINYIN_COMMITTING_CHARS = new Set([
                "+",
                "-",
                "'",
                '"',
                "!",
                "@",
                "#",
                "$",
                "%",
                "^",
                "&",
                "*",
                "(",
                ")",
                "_",
                "=",
                "~",
                "`",
                "{",
                "}",
                "[",
                "]",
                "|",
                "\\",
                ":",
                ";",
                "<",
                ">",
                "?",
                "/",
            ]);

            function getDictLevel(dict) {
                return typeof dict.level === "number" ? dict.level : 100; // Use 100 as per strong recommendation
            }

            class Trie {
                constructor() {
                    this.root = { children: {}, values: [] };
                }

                insert(key, value) {
                    let node = this.root;
                    for (const char of key) {
                        if (!node.children[char]) {
                            node.children[char] = { children: {}, values: [] };
                        }
                        node = node.children[char];
                    }
                    const items = Array.isArray(value) ? value : [value];
                    node.values.push(...items);
                }

                getNode(prefix) {
                    let node = this.root;
                    for (const char of prefix) {
                        if (!node.children[char]) return null;
                        node = node.children[char];
                    }
                    return node;
                }
            }

            let DB = new Trie();
            let allDicts = []; // This will now be loaded directly from localStorage

            let settings = JSON.parse(
                localStorage.getItem("ime_settings") || "{}",
            );
            console.log("Settings loaded:", settings); // Debugging line
            if (typeof settings.outputFlexGrow === "undefined")
                settings.outputFlexGrow = 2;
            if (typeof settings.inputFlexGrow === "undefined")
                settings.inputFlexGrow = 3;
            if (typeof settings.history === "undefined")
                settings.history = true;

            let activeLanguage = "chinese";
            let buffer = "",
                committed = "",
                enFilter = "";

            let practiceWords = [];
            let currentPracticeWordIndex = 0;
            const PRACTICE_DICT_NAME = "ËØçÁªÑËØçÂÖ∏";
            const PRACTICE_PROGRESS_KEY = "webime_practice_progress";
            let isPracticeAnimating = false;

            let combinedCandidates = [],
                pageIndex = 0;
            const pageSize = 10; // Moved pageSize outside InputState logic
            let HISTORY = JSON.parse(
                localStorage.getItem("ime_history_v18") || "[]",
            );

            const hInput = document.getElementById("hidden-input");
            const outputArea = document.getElementById("output-area");
            const correctionWrapper =
                document.getElementById("correction-wrapper");
            const correctionInput = document.getElementById("correction-input");
            const mainCandidates = document.getElementById("main-candidates"); // Define mainCandidates

            // New practice mode variables
            let cardLeft, cardCenter, cardRight;
            let currentInputDisplay; // For the visual buffer
            let practiceCards = []; // Array to hold the three active card elements
            let completedRightCardWord = null; // Stores the word for the card on the far right

            const PRACTICE_MODE_INPUT_ID = "practice-input-display";

            async function init() {
                try {
                    console.log("ÂºÄÂßãÂàùÂßãÂåñËæìÂÖ•Ê≥ï...");
                    showLoadingMessage("Ê≠£Âú®ÂàùÂßãÂåñËæìÂÖ•Ê≥ï...");

                    // Core components setup
                    await Promise.all([
                        initInputHandler(),
                        initUI(),
                        initEventListeners(),
                    ]);

                    // Load settings and dictionaries
                    loadDictConfig(); // Load allDicts from localStorage or built-in
                    await loadAllDicts(); // Populate the Trie with enabled dicts
                    applySettings(); // Apply saved layout settings

                    // Validate initialization
                    const isValid = validateInitialization();
                    if (!isValid) {
                        throw new Error("ÂàùÂßãÂåñÈ™åËØÅÂ§±Ë¥•");
                    }

                    // Start input method
                    startInputMethod();

                    console.log("ËæìÂÖ•Ê≥ïÂàùÂßãÂåñÂÆåÊàê");
                    hideLoadingMessage();
                } catch (error) {
                    console.error("ËæìÂÖ•Ê≥ïÂàùÂßãÂåñÂ§±Ë¥•:", error);
                    showErrorMessage("ËæìÂÖ•Ê≥ïÂàùÂßãÂåñÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï");
                    hideLoadingMessage();
                }
            }

            function validateInitialization() {
                const checks = [
                    {
                        name: "ÈöêËóèËæìÂÖ•Ê°Ü",
                        check: () => !!document.getElementById("hidden-input"),
                    },
                    {
                        name: "ÂÄôÈÄâËØçÂå∫Âüü",
                        check: () =>
                            !!document.getElementById("main-candidates"),
                    },
                    {
                        name: "TrieÊ†ëÊúâÊï∞ÊçÆ",
                        check: () =>
                            DB.root.children &&
                            Object.keys(DB.root.children).length > 0,
                    },
                ];

                for (const check of checks) {
                    if (!check.check()) {
                        console.error(`ÂàùÂßãÂåñÊ£ÄÊü•Â§±Ë¥•: ${check.name}`);
                        return false;
                    }
                }

                return true;
            }

            // --- Missing function definitions (from gemini.md) ---
            /**
             * Â¢ûÂº∫ÁöÑstartInputMethodÂáΩÊï∞ÔºåÂåÖÂê´ÂéÜÂè≤ËÆ∞ÂΩïÂàùÂßãÂåñ
             */
            function startInputMethod() {
                try {
                    console.log("ÂêØÂä®ËæìÂÖ•Ê≥ïÊ†∏ÂøÉÂäüËÉΩ...");

                    // ÂàùÂßãÂåñÂéÜÂè≤ËÆ∞ÂΩï
                    const savedHistory =
                        localStorage.getItem("ime_history_v18");
                    let historyItems = [];

                    if (savedHistory) {
                        try {
                            historyItems = JSON.parse(savedHistory);
                            if (!Array.isArray(historyItems)) {
                                historyItems = [];
                            }
                        } catch (e) {
                            console.warn("ÂéÜÂè≤ËÆ∞ÂΩïËß£ÊûêÂ§±Ë¥•ÔºåÈáçÁΩÆ‰∏∫Á©∫Êï∞ÁªÑ");
                            historyItems = [];
                        }
                    }

                    // Êõ¥Êñ∞ÂéÜÂè≤ËÆ∞ÂΩïUI
                    updateHistoryUI(historyItems);

                    // ÁªëÂÆöÂéÜÂè≤ËÆ∞ÂΩï‰øùÂ≠ò
                    // This part needs to be integrated with existing commit logic
                    // For now, let's just make sure the updateHistoryUI is called
                    // on commit in the general update loop or dedicated commit function.

                    // Set initial state and update UI
                    setState(InputState.NORMAL);
                    update();

                    // ÊòæÁ§∫ÂêØÂä®ÊàêÂäüÊ∂àÊÅØ

                    console.log("ËæìÂÖ•Ê≥ïÂêØÂä®ÂÆåÊàê");
                } catch (error) {
                    console.error("ÂêØÂä®ËæìÂÖ•Ê≥ïÂ§±Ë¥•:", error);
                    showErrorMessage("ÂêØÂä®ËæìÂÖ•Ê≥ïÂ§±Ë¥•", error);
                }
            }
            // --- End Missing function definitions ---

            function showErrorMessage(message, error = null) {
                console.error("ËæìÂÖ•Ê≥ïÈîôËØØ:", message, error);
                showToast(
                    `${message}${error ? ": " + error.message : ""}`,
                    "error",
                    5000,
                );
            }

            // This function now only retrieves allDicts from localStorage and ensures it's initialized
            function loadDictConfig() {
                const storedDicts = JSON.parse(
                    localStorage.getItem("ime_dicts_config"),
                );
                if (storedDicts && storedDicts.length > 0) {
                    // Check if storedDicts is not empty
                    allDicts = storedDicts;
                    // Add any new built-in dicts that aren't already in stored config
                    BUILT_IN_DICTS.forEach((builtInDict) => {
                        if (
                            !allDicts.find(
                                (d) =>
                                    d.path === builtInDict.path &&
                                    d.type === builtInDict.type,
                            )
                        ) {
                            allDicts.push(builtInDict);
                        }
                    });
                } else {
                    allDicts = [...BUILT_IN_DICTS];
                }

                // Initialize practice dicts settings for newly added dicts if not present
                if (!settings.practice_dicts) {
                    settings.practice_dicts = {};
                }
                allDicts.forEach((dict, index) => {
                    if (settings.practice_dicts[index] === undefined) {
                        settings.practice_dicts[index] = false; // Default to not selected for practice
                    }
                });
                // No saveDictConfig here, as this is just loading initial state
            }

            function saveDictConfig() {
                localStorage.setItem(
                    "ime_dicts_config",
                    JSON.stringify(allDicts),
                );
                saveSettings(); // Ensure global settings are saved too
            }

            function calculateWordCount(dictContent) {
                let count = 0;
                for (const k in dictContent) {
                    count += Array.isArray(dictContent[k])
                        ? dictContent[k].length
                        : 1;
                }
                return count;
            }

            async function loadAllDicts() {
                DB = new Trie(); // Reset Trie before loading
                console.log("Âä†ËΩΩËØçÂÖ∏‰∏≠...");

                const loadPromises = allDicts
                    .filter((d) => d.enabled) // Only load enabled dictionaries
                    .map((dict) => {
                        return new Promise(async (resolve) => {
                            try {
                                console.log(
                                    `Â∞ùËØïÂä†ËΩΩËØçÂÖ∏: ${dict.name} (enabled: ${dict.enabled})`,
                                );
                                let dictData;
                                if (dict.type === "built-in") {
                                    const response = await fetch(dict.path);
                                    if (!response.ok) {
                                        console.error(
                                            `Êó†Ê≥ïÂä†ËΩΩÂÜÖÁΩÆËØçÂÖ∏ ${dict.name}: ${response.status}`,
                                        );
                                        return resolve(); // Resolve even on error to allow other dicts to load
                                    }
                                    dictData = await response.json();
                                    dict.fetchedContent = dictData; // Store fetched content
                                } else if (
                                    dict.type === "user" &&
                                    dict.content
                                ) {
                                    dictData = JSON.parse(dict.content);
                                }

                                if (dictData) {
                                    let currentWordCount = 0;
                                    for (const k in dictData) {
                                        const key = k.toLowerCase();
                                        const items = Array.isArray(dictData[k])
                                            ? dictData[k]
                                            : [dictData[k]];
                                        DB.insert(key, items);
                                        currentWordCount += items.length;
                                    }
                                    dict.wordCount = currentWordCount; // Update wordCount directly on the dict object
                                }
                            } catch (e) {
                                console.error(
                                    "Failed to load or parse dict:",
                                    dict.name,
                                    e,
                                );
                            }
                            resolve();
                        });
                    });
                await Promise.all(loadPromises);
                console.log("ÊâÄÊúâÂêØÁî®ÁöÑËØçÂÖ∏Âä†ËΩΩÂÆåÊàê„ÄÇ");
            }

            function applySettings() {
                const outputCard = document.getElementById("output-card");
                const inputCard = document.getElementById("input-container");

                if (outputCard) {
                    outputCard.style.flexGrow = settings.outputFlexGrow;
                }
                if (inputCard) {
                    inputCard.style.flexGrow = settings.inputFlexGrow;
                }

                document.getElementById("historyPanel").style.display = // Corrected ID
                    settings.history ? "flex" : "none"; // Changed to flex/none for the panel
                document
                    .getElementById("l-hist-btn")
                    .classList.toggle("active", settings.history);
                console.log(
                    "Applying settings - outputFlexGrow:",
                    settings.outputFlexGrow,
                    "inputFlexGrow:",
                    settings.inputFlexGrow,
                ); // Debugging line
            }

            function update() {
                if (currentState === InputState.EDIT) return;

                outputArea.innerText = committed;
                outputArea.scrollTop = outputArea.scrollHeight;

                if (buffer) {
                    const b = buffer.toLowerCase();
                    let bufferHTML = escapeHtml(b); // Display buffer as typed pinyin
                    if (currentState === InputState.TAB) {
                        bufferHTML += "-";
                        if (enFilter) {
                            bufferHTML += ` <span style="color: #ff9500;">${escapeHtml(enFilter)}</span>`;
                        }
                    }
                    document.getElementById("buffer-display").innerHTML =
                        bufferHTML;

                    let list = [];
                    const isAllVowels = (str) => /^[aeiou]+$/.test(str);

                    let useExactMatch = false;
                    if (
                        b.length <= 2 ||
                        ((b.length === 3 || b.length === 4) && isAllVowels(b))
                    ) {
                        useExactMatch = true;
                    }

                    const prefixNode = DB.getNode(b);

                    if (prefixNode) {
                        const collect = (node, path) => {
                            if (useExactMatch && path !== b) {
                                return;
                            }
                            if (node.values.length > 0) {
                                let weight = 1000;
                                if (path === b) weight += 10000; // Exact match bonus
                                weight -= (path.length - b.length) * 100;

                                node.values.forEach((i) =>
                                    list.push({
                                        text: i.char || i,
                                        desc:
                                            i.en ||
                                            (typeof i === "object" ? i.en : ""),
                                        w: weight,
                                    }),
                                );
                            }

                            if (!useExactMatch) {
                                for (const char in node.children) {
                                    collect(node.children[char], path + char);
                                }
                            }
                        };
                        collect(prefixNode, b);
                    }

                    const seen = new Set();
                    combinedCandidates = list
                        .sort((a, b) => b.w - a.w)
                        .filter((x) => !seen.has(x.text) && seen.add(x.text));

                    if (
                        b.length >= 6 &&
                        DB.getNode(b) &&
                        DB.getNode(b).values.length === 1 &&
                        currentState !== InputState.TAB
                    ) {
                        const word = combinedCandidates[0].text;
                        setTimeout(() => selectCandidate(word), 10);
                        return;
                    }
                } else {
                    document.getElementById("buffer-display").innerText = "";
                    combinedCandidates = [];
                }
                render();
            }

            function escapeHtml(text = "") {
                return String(text)
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            }

            function render() {
                let display = combinedCandidates;
                if (currentState === InputState.TAB && enFilter) {
                    display = combinedCandidates.filter(
                        (i) =>
                            i.desc &&
                            i.desc
                                .toLowerCase()
                                .startsWith(enFilter.toLowerCase()),
                    );
                    if (display.length === 1) {
                        selectCandidate(display[0].text);
                        return;
                    }
                }
                const totalPages = Math.ceil(display.length / pageSize);
                document.getElementById("page-counter").innerText =
                    buffer && display.length > 0
                        ? `${pageIndex + 1} / ${totalPages || 1}`
                        : "";
                const pageData = display.slice(
                    pageIndex * pageSize,
                    (pageIndex + 1) * pageSize,
                );
                document.getElementById("main-candidates").innerHTML = pageData
                    .map(
                        (item, i) => `
                    <div class="candidate-item" onclick="selectCandidate('${item.text}')">
                        <span class="cand-key">${(i + 1) % 10}</span><div class="cand-text">${item.text}</div>
                        ${item.desc ? `<div class="cand-desc">${item.desc}</div>` : ""}
                    </div>`,
                    )
                    .join("");
            }

            function selectCandidate(t) {
                committed += t;
                resetInput();
                update();
            }

            function resetInput() {
                // Before clearing buffer, check if committed has new content to save to history
                // Only save if committed has content AND it's different from the last history item
                // (to avoid duplicate entries if resetInput is called multiple times without new committed content)
                if (
                    committed.trim() &&
                    (HISTORY.length === 0 ||
                        HISTORY[0].text !== committed.trim())
                ) {
                    const historyItem = {
                        text: committed.trim(),
                        timestamp: Date.now(),
                    };
                    HISTORY.unshift(historyItem); // Add to the beginning
                    saveHistory(); // Save the updated history
                }

                setBuffer(""); // Consolidates buffer = "" and hInput.value = ""
                enFilter = "";
                setState(InputState.NORMAL); // Reset tab state
                pageIndex = 0;
            }

            function handleKeyDown(e) {
                if (currentState === InputState.CORRECTION) return;
                const key = e.key;

                // Handle correction mode shortcut (Ctrl+I) globally
                if (e.ctrlKey && key.toLowerCase() === "i") {
                    e.preventDefault();
                    enterCorrectionMode();
                    return;
                }

                // --- Normal Mode Logic Below ---

                // Handle specific non-IME characters: +, -, ', etc.
                if (NON_PINYIN_COMMITTING_CHARS.has(key)) {
                    e.preventDefault();
                    if (buffer && combinedCandidates.length > 0) {
                        committed += combinedCandidates[0].text;
                    }
                    committed += key;
                    resetInput();
                    update();
                    return;
                }

                // Punctuation handling for normal mode
                if (PUNCS[key]) {
                    e.preventDefault();
                    if (buffer && combinedCandidates.length > 0)
                        committed += combinedCandidates[0].text;
                    committed += PUNCS[key];
                    resetInput();
                    update();
                    return;
                }

                // Paging candidates with '=' or '-'
                if (buffer && currentState !== InputState.TAB) {
                    if (key === "=") {
                        e.preventDefault();
                        if (
                            (pageIndex + 1) * pageSize <
                            combinedCandidates.length
                        ) {
                            pageIndex++;
                            render();
                        }
                        return;
                    }
                    if (key === "-") {
                        e.preventDefault();
                        if (pageIndex > 0) {
                            pageIndex--;
                            render();
                        }
                        return;
                    }
                }

                // TAB key handling
                if (key === "Tab") {
                    e.preventDefault();
                    if (buffer) {
                        setState(
                            currentState === InputState.TAB
                                ? InputState.NORMAL
                                : InputState.TAB,
                        );
                        enFilter = "";
                        update();
                    }
                    return;
                }

                // TAB mode specific char/backspace
                if (currentState === InputState.TAB && buffer) {
                    if (/^[a-zA-Z]$/.test(key)) {
                        e.preventDefault();
                        enFilter += key.toLowerCase();
                        pageIndex = 0;
                        render();
                        return;
                    }
                    if (key === "Backspace") {
                        e.preventDefault();
                        if (enFilter) {
                            enFilter = enFilter.slice(0, -1);
                            render();
                        } else {
                            setState(InputState.NORMAL);
                            update();
                        }
                        return;
                    }
                }

                // Numeric selection '0'-'9' for normal mode
                if (/^[0-9]$/.test(key)) {
                    e.preventDefault();
                    if (buffer && combinedCandidates.length > 0) {
                        const idx = key === "0" ? 9 : parseInt(key) - 1;
                        const list =
                            currentState === InputState.TAB && buffer
                                ? combinedCandidates.filter(
                                      (c) =>
                                          c.desc &&
                                          c.desc
                                              .toLowerCase()
                                              .startsWith(enFilter),
                                  )
                                : combinedCandidates;
                        const pageData = list.slice(
                            pageIndex * pageSize,
                            (pageIndex + 1) * pageSize,
                        );
                        if (pageData[idx]) selectCandidate(pageData[idx].text);
                    } else if (!buffer) {
                        committed += key;
                        update();
                    }
                } else if (key === "Enter") {
                    if (currentState === InputState.PRACTICE) {
                        e.preventDefault();
                        return;
                    }
                    // Enter key for normal mode
                    e.preventDefault();
                    if (buffer) {
                        committed += buffer;
                        resetInput();
                    } else {
                        committed += "\n";
                    }
                    update();
                } else if (key === "Backspace") {
                    // Backspace for normal mode
                    e.preventDefault();
                    if (buffer) {
                        buffer = buffer.slice(0, -1);
                        hInput.value = buffer;
                        update();
                    } else if (committed) {
                        committed = committed.slice(0, -1);
                        update();
                    }
                } else if (key === " ") {
                    // Space for normal mode
                    e.preventDefault();
                    if (buffer) {
                        const list =
                            currentState === InputState.TAB && buffer
                                ? combinedCandidates.filter(
                                      (c) =>
                                          c.desc &&
                                          c.desc
                                              .toLowerCase()
                                              .startsWith(enFilter),
                                  )
                                : combinedCandidates;
                        const pageData = list.slice(
                            pageIndex * pageSize,
                            (pageIndex + 1) * pageSize,
                        );
                        if (pageData[0]) selectCandidate(pageData[0].text);
                    } else {
                        committed += " ";
                        update();
                    }
                }
            }

            // New function to update the visual practice input display
            function updatePracticeInputDisplay() {
                if (
                    currentState !== InputState.PRACTICE ||
                    !currentInputDisplay
                )
                    return;

                const currentWord = practiceWords[currentPracticeWordIndex];
                const targetPinyin = currentWord.pinyin.toLowerCase();
                const typedPinyin = buffer.toLowerCase();

                let displayHTML = "";
                for (let i = 0; i < targetPinyin.length; i++) {
                    const char = targetPinyin[i];
                    if (i < typedPinyin.length) {
                        if (typedPinyin[i] === char) {
                            displayHTML += `<span class="correct-char">${char}</span>`;
                        } else {
                            displayHTML += `<span class="incorrect-char">${char}</span>`;
                        }
                    } else {
                        displayHTML += `<span>${char}</span>`;
                    }
                }
                currentInputDisplay.innerHTML = displayHTML;
            }

            function handleInput(event) {
                if (currentState === InputState.PRACTICE) {
                    setBuffer(
                        event.target.value.toLowerCase().replace(/[^a-z]/g, ""),
                    );
                    updatePracticeInputDisplay();

                    const currentWord = practiceWords[currentPracticeWordIndex];
                    if (!currentWord) return;

                    const targetPinyin = currentWord.pinyin.toLowerCase();
                    const typedPinyin = buffer;

                    if (typedPinyin === targetPinyin) {
                        currentPracticeWordIndex++;
                        localStorage.setItem(
                            PRACTICE_PROGRESS_KEY,
                            currentPracticeWordIndex,
                        );

                        const progressBar =
                            document.getElementById("progress-bar");
                        const progress =
                            (currentPracticeWordIndex / practiceWords.length) *
                            100;
                        progressBar.style.width = `${progress}%`;

                        setTimeout(() => {
                            showNextPracticeWord();
                        }, 100);
                    }
                    return;
                }
                if (
                    currentState !== InputState.TAB &&
                    currentState !== InputState.EDIT
                ) {
                    setBuffer(hInput.value.replace(/[^a-zA-Z]/g, ""));
                    pageIndex = 0; // Reset page index on new input
                    update();
                }
            }

            function handleGlobalKeyDown(e) {
                const key = e.key.toLowerCase();
                if (e.ctrlKey && key === "e") {
                    e.preventDefault();
                    toggleEditMode();
                    return;
                }
                if (e.ctrlKey && key === "c") {
                    if (
                        currentState !== InputState.EDIT &&
                        currentState !== InputState.CORRECTION
                    ) {
                        e.preventDefault();
                        archiveAndCopy();
                    }
                    return;
                }
                if (e.key === "escape") {
                    if (currentState === InputState.EDIT)
                        setState(InputState.NORMAL);
                    if (currentState === InputState.CORRECTION) {
                        e.preventDefault();
                        exitCorrectionMode("update_buffer");
                    }
                }
            }

            function handleCorrectionKeyDown(e) {
                if (e.key === "Enter") {
                    e.preventDefault();
                    exitCorrectionMode("convert_sentence");
                } else if (e.key === "Escape") {
                    e.preventDefault();
                    exitCorrectionMode("sync_out_buffer"); // Sync Out: Escape key
                } else if (e.ctrlKey && e.key.toLowerCase() === "i") {
                    e.preventDefault();
                    exitCorrectionMode("convert_sentence");
                }
            }

            function handleGlobalClick(e) {
                if (
                    currentState === InputState.EDIT &&
                    outputArea.contains(e.target)
                )
                    return;
                if (
                    currentState === InputState.CORRECTION &&
                    correctionWrapper.contains(e.target)
                )
                    return;
                // Clicking on import button is now handled by settings.html, remove from index.html
                // if (e.target.id === "file-uploader") return;
                updateFocus(); // Keep focus where it should be based on state
            }

            function handleVisibilityChange() {
                if (!document.hidden) updateFocus(); // Restore focus on tab switch
            }

            function makeResizableV(resizerId, topPanelId, bottomPanelId) {
                const resizer = document.getElementById(resizerId);
                const topPanel = document.getElementById(topPanelId);
                const bottomPanel = document.getElementById(bottomPanelId);
                const parentPanel = topPanel.parentElement; // Should be center-container

                let startY,
                    startTopFlexGrow,
                    startBottomFlexGrow,
                    totalHeight,
                    parentRect;

                resizer.addEventListener("mousedown", (e) => {
                    e.preventDefault();

                    // Get current computed flex-grow values
                    startTopFlexGrow = parseFloat(
                        window.getComputedStyle(topPanel).flexGrow,
                    );
                    startBottomFlexGrow = parseFloat(
                        window.getComputedStyle(bottomPanel).flexGrow,
                    );

                    // If not set, use default or initial values
                    if (isNaN(startTopFlexGrow) || startTopFlexGrow === 0)
                        startTopFlexGrow = 2;
                    if (isNaN(startBottomFlexGrow) || startBottomFlexGrow === 0)
                        startBottomFlexGrow = 3;

                    totalHeight = parentPanel.offsetHeight; // Total height of the flex container
                    parentRect = parentPanel.getBoundingClientRect(); // Get bounding rect once

                    const doDrag = (ev) => {
                        // Calculate mouse position relative to the parentPanel
                        const mouseY = ev.clientY - parentRect.top;

                        // Calculate new top panel height based on mouse position
                        let newTopHeight = mouseY;
                        let newBottomHeight = parentRect.height - mouseY;

                        // Ensure minimum heights
                        const minHeight = 100; // Define a reasonable minimum height
                        if (newTopHeight < minHeight) {
                            newTopHeight = minHeight;
                        }
                        if (newBottomHeight < minHeight) {
                            newBottomHeight = minHeight;
                        }

                        // Calculate new flex-grow ratios based on the adjusted split point
                        const sumFlexGrow =
                            startTopFlexGrow + startBottomFlexGrow;

                        let newTopFlexGrow =
                            (newTopHeight / parentRect.height) * sumFlexGrow;
                        let newBottomFlexGrow = sumFlexGrow - newTopFlexGrow;

                        requestAnimationFrame(() => {
                            topPanel.style.flexGrow = newTopFlexGrow;
                            bottomPanel.style.flexGrow = newBottomFlexGrow;
                        });
                    };

                    const stopDrag = () => {
                        document.removeEventListener("mousemove", doDrag);
                        document.removeEventListener("mouseup", stopDrag);

                        // Save the final flex-grow values
                        settings.outputFlexGrow = parseFloat(
                            topPanel.style.flexGrow,
                        );
                        settings.inputFlexGrow = parseFloat(
                            bottomPanel.style.flexGrow,
                        );
                        saveSettings();
                    };

                    document.addEventListener("mousemove", doDrag);
                    document.addEventListener("mouseup", stopDrag);
                });
            }

            document.addEventListener("DOMContentLoaded", () => {
                makeResizableV(
                    "center-v-resizer",
                    "output-card",
                    "input-container",
                );
                init();
            });
        </script>
    </body>
</html>
