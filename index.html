<!doctype html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>Web IME Pro | 导入与长句修正版</title>
        <script src="dicts_config.js"></script>
        <style>
            :root {
                --primary: #007aff;
                --bg: #f2f2f7;
                --panel-bg: #ffffff;
                --item-bg: #f9f9f9;
                --item-border: #eee;
                --github-dark: #24292e;
            }
            body {
                font-family: system-ui, sans-serif;
                background: var(--bg);
                margin: 0;
                padding: 15px;
                height: 100vh;
                display: flex;
                justify-content: center;
                overflow: hidden;
            }
            .main-layout {
                display: flex;
                flex-direction: column;
                gap: 15px;
                width: 100%;
                max-width: 1900px;
                height: 96vh;
            }
            .toolbar {
                background: var(--panel-bg);
                padding: 10px 20px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }
            .btn {
                padding: 6px 14px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 12px;
                transition: 0.2s;
                display: flex;
                align-items: center;
                gap: 5px;
            }
            .btn-toggle {
                background: #e5e5ea;
                color: #333;
            }
            .btn-toggle.active {
                background: var(--primary);
                color: white;
            }
            .btn-action {
                background: #34c759;
                color: white;
            }
            .btn-github {
                background: var(--github-dark);
                color: white;
                text-decoration: none;
                margin-left: auto;
            }
            .content-area {
                flex: 1;
                display: flex;
                gap: 15px;
                min-height: 0;
                position: relative;
            }
            .resizer {
                width: 6px;
                background: #ddd;
                cursor: col-resize;
                z-index: 10;
            }
            .resizer-v {
                height: 6px;
                background: #ddd;
                cursor: row-resize;
                z-index: 10;
                margin: 2px 0;
            }
            .history-panel {
                flex: 0 0 260px;
                background: #fff;
                border-radius: 16px;
                padding: 15px;
                display: flex;
                flex-direction: column;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            }
            .center-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-width: 400px;
                max-width: 1000px;
                margin: 0 auto;
            }
            .output-card {
                background: white;
                border-radius: 20px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
                position: relative;
                display: flex;
                flex-direction: column;
                min-height: 100px;
                border: 2px solid transparent;
            }
            .output-card.editing {
                border: 2px solid #ff9500;
            }
            #output-area {
                flex: 1;
                padding: 25px;
                font-size: 24px;
                line-height: 1.6;
                word-break: break-all;
                white-space: pre-wrap;
                overflow-y: auto;
                outline: none;
            }
            .practice-hint {
                color: #d1d1d6;
                pointer-events: none;
            }
            .caret {
                display: inline-block;
                width: 2px;
                height: 1em;
                background: var(--primary);
                animation: blink 1s infinite;
                vertical-align: bottom;
            }

            #output-area.locked::after {
                content: "";
                display: inline-block;
                width: 2px;
                height: 28px;
                background: var(--primary);
                vertical-align: middle;
                margin-left: 2px;
                animation: blink 1s infinite;
            }
            @keyframes blink {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0;
                }
            }
            .control-group {
                position: absolute;
                right: 15px;
                bottom: 15px;
                display: flex;
                gap: 8px;
                z-index: 100;
            }
            .input-card {
                background: white;
                padding: 20px;
                border-radius: 20px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                border: 3px solid transparent;
                position: relative;
            }
            .input-card.tab-mode {
                border-color: var(--primary);
                background: #f0f7ff;
            }
            .input-status-bar {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
                min-height: 30px;
            }
            #buffer-display {
                font-size: 18px;
                color: var(--primary);
                font-weight: bold;
                margin-bottom: 5px;
            }
            #main-candidates {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                min-height: 50px;
            }
            .candidate-item {
                position: relative;
                padding: 10px 15px;
                background: var(--item-bg);
                border-radius: 10px;
                cursor: pointer;
                font-size: 22px;
                font-weight: 500;
                border: 1px solid var(--item-border);
                transition: background-color 0.2s;
            }
            .candidate-item:hover {
                background-color: #e0e0e0;
            }
            .cand-key {
                position: absolute;
                top: 2px;
                left: 4px;
                font-size: 10px;
                opacity: 0.5;
                color: var(--primary);
                font-weight: bold;
            }
            #hidden-input {
                position: fixed;
                left: -999px;
                opacity: 0;
            }

            #correction-wrapper {
                position: absolute;
                bottom: 20px;
                left: 20px;
                right: 20px;
                background: white;
                box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
                border-radius: 12px;
                padding: 15px;
                display: none;
                z-index: 200;
                border: 2px solid var(--primary);
            }
            #correction-input {
                width: 100%;
                font-size: 20px;
                border: none;
                outline: none;
                font-family: system-ui;
                color: #333;
                font-weight: 500;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
            }
            .correction-tip {
                font-size: 12px;
                color: #888;
                margin-top: 8px;
                display: flex;
                justify-content: space-between;
            }

            #toast {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #333;
                color: white;
                padding: 8px 20px;
                border-radius: 20px;
                opacity: 0;
                transition: 0.3s;
                z-index: 999;
                pointer-events: none;
            }
            #file-uploader {
                display: none;
            }
            .history-panel {
                position: fixed;
                bottom: 60px;
                right: 20px;
                width: 300px;
                max-height: 400px;
                background: white;
                border: 1px solid #ddd;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                z-index: 1000;
                overflow: hidden;
                display: none; /* Hidden by default */
            }
            .history-header {
                padding: 12px 16px;
                background: #f5f5f5;
                border-bottom: 1px solid #ddd;
                font-weight: bold;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .history-list {
                list-style: none;
                padding: 0;
                margin: 0;
                max-height: 350px;
                overflow-y: auto;
            }
            .history-item {
                padding: 10px 16px;
                border-bottom: 1px solid #f0f0f0;
                cursor: pointer;
                transition: background 0.2s;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .history-item:hover {
                background: #f8f8f8;
            }
            .history-item.empty {
                color: #999;
                cursor: default;
            }
            .history-item.empty:hover {
                background: transparent;
            }
            .history-time {
                font-size: 12px;
                color: #666;
                min-width: 50px;
            }
            .history-text {
                flex: 1;
                margin-left: 10px;
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
            }
            .input-method-toast {
                position: fixed;
                top: 20px;
                right: 20px;
                background: #333;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 9999;
                display: flex;
                align-items: center;
                gap: 10px;
                opacity: 0;
                transform: translateY(-20px);
                transition: opacity 0.3s, transform 0.3s;
                max-width: 300px;
                font-size: 14px;
            }
            .input-method-toast.show {
                opacity: 1;
                transform: translateY(0);
            }
            .toast-success { background: #4CAF50; border-left: 4px solid #2E7D32; }
            .toast-error { background: #F44336; border-left: 4px solid #C62828; }
            .toast-warning { background: #FF9800; border-left: 4px solid #EF6C00; }
            .toast-info { background: #2196F3; border-left: 4px solid #1565C0; }
            .toast-icon { font-weight: bold; font-size: 16px; }
            .toast-content { flex: 1; }
            .toast-close { background: transparent; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0 5px; opacity: 0.7; transition: opacity 0.2s; }
            .toast-close:hover { opacity: 1; }
            #loading-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 255, 255, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                flex-direction: column;
                z-index: 1000;
                font-size: 24px;
                color: var(--primary);
                display: none; /* Hidden by default */
            }
            #loading-spinner {
                border: 4px solid #f3f3f3;
                border-top: 4px solid var(--primary);
                border-radius: 50%;
                width: 40px;
                height: 40px;
                animation: spin 1s linear infinite;
                margin-bottom: 20px;
            }
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>
    <body>
        <div class="main-layout">
            <div class="toolbar">
                <button
                    id="l-hist-btn"
                    class="btn btn-toggle"
                    onclick="toggleHistoryPanel()"
                >
                    历史记录
                </button>
                <div
                    style="
                        width: 1px;
                        height: 20px;
                        background: #ddd;
                        margin: 0 5px;
                    "
                ></div>
                <button
                    class="btn btn-action"
                    onclick="document.getElementById('file-uploader').click()"
                >
                    导入词库
                </button>


                <button
                    id="practice-btn"
                    class="btn btn-toggle"
                    onclick="togglePracticeMode()"
                >
                    练习模式
                </button>

                <div
                    style="
                        width: 1px;
                        height: 20px;
                        background: #ddd;
                        margin: 0 5px;
                    "
                ></div>

                <input
                    type="file"
                    id="file-uploader"
                    accept=".json"
                    onchange="handleImportDict(this)"
                />

                <a
                    href="hanzi_explorer.html"
                    class="btn btn-toggle"
                    >汉字浏览器</a
                >
                <a
                    href="https://github.com/123qweraz/webime"
                    target="_blank"
                    class="btn btn-github"
                    >GitHub Star</a
                >
                <a
                    href="settings.html"
                    target="_blank"
                    class="btn btn-toggle"
                    >词典设置</a
                >
            </div>
            <div class="content-area">
                <div class="history-panel" id="historyPanel">
                    <div class="history-header">
                        <span>输入历史</span>
                        <button onclick="toggleHistoryPanel()" 
                                style="background:none; border:none; cursor:pointer; font-size:16px;">×</button>
                    </div>
                    <ul id="historyList" class="history-list"></ul>
                </div>
                <div class="resizer" id="left-resizer"></div>
                <div class="center-container">
                    <div class="output-card" id="output-card">
                        <div
                            id="output-area"
                            class="locked"
                            spellcheck="false"
                            oninput="syncFromEditor()"
                        ></div>
                        <div class="control-group">
                            <button
                                id="edit-mode-btn"
                                class="btn btn-toggle"
                                onclick="toggleEditMode()"
                            >
                                锁定模式
                            </button>
                            <button
                                class="btn btn-toggle active"
                                style="background: #222"
                                onclick="archiveAndCopy()"
                            >
                                归档并复制
                            </button>
                        </div>
                    </div>
                    <div class="resizer-v" id="center-v-resizer"></div>
                    <div
                        class="input-card"
                        id="input-container"
                        onclick="focusHiddenInput()"
                    >
                        <div class="input-status-bar">
                            <div id="buffer-display"></div>
                            <div id="page-counter"></div>
                        </div>
                        <div id="main-candidates"></div>

                        <div id="correction-wrapper">
                            <input
                                type="text"
                                id="correction-input"
                                autocomplete="off"
                                placeholder="输入拼音短语，用空格分隔，如: ni hao"
                            />
                            <div class="correction-tip">
                                <span>支持长句输入 (空格分隔)</span>
                                <span>Enter 上屏 / Esc 取消</span>
                            </div>
                        </div>

                        <input
                            type="text"
                            id="hidden-input"
                            autocomplete="off"
                        />
                    </div>
                </div>
            </div>
        </div>
        <div id="loading-overlay">
            <div id="loading-spinner"></div>
            <p>正在初始化输入法...</p>
        </div>
        <div id="toast"></div>

        <script>

            // --- Missing functions (from gemini.md) ---
            /**
             * 更新历史记录UI显示
             * @param {Array} historyItems - 历史记录条目数组
             */
            function updateHistoryUI(historyItems) {
                try {
                    const historyList = document.getElementById('historyList');
                    if (!historyList) {
                        console.warn('历史记录容器元素未找到');
                        return;
                    }
                    
                    // 清空现有内容
                    historyList.innerHTML = '';
                    
                    // 如果没有历史记录，显示提示
                    if (!historyItems || historyItems.length === 0) {
                        const emptyItem = document.createElement('li');
                        emptyItem.className = 'history-item empty';
                        emptyItem.textContent = '暂无输入历史';
                        historyList.appendChild(emptyItem);
                        return;
                    }
                    
                    // 显示最近的历史记录（最多20条）
                    const recentItems = historyItems.slice(0, 20);
                    
                    recentItems.forEach(item => {
                        const listItem = document.createElement('li');
                        listItem.className = 'history-item';
                        
                        const timeSpan = document.createElement('span');
                        timeSpan.className = 'history-time';
                        
                        if (item.timestamp) {
                            const date = new Date(item.timestamp);
                            timeSpan.textContent = date.toLocaleTimeString([], { 
                                hour: '2-digit', 
                                minute: '2-digit' 
                            });
                        } else {
                            timeSpan.textContent = '刚刚';
                        }
                        
                        const textSpan = document.createElement('span');
                        textSpan.className = 'history-text';
                        textSpan.textContent = item.text || item;
                        
                        listItem.appendChild(timeSpan);
                        listItem.appendChild(textSpan);
                        
                        // 点击历史项回填到输入框
                        listItem.addEventListener('click', () => {
                            const inputElement = document.getElementById('hidden-input'); // Use hidden-input
                            if (inputElement && inputElement.value !== undefined) {
                                inputElement.value = item.text || item;
                                // 触发输入事件以更新候选词
                                const inputEvent = new Event('input', { bubbles: true });
                                inputElement.dispatchEvent(inputEvent);
                                
                                // 显示成功提示
                                showToast('已回填到输入框', 'success');
                            }
                        });
                        
                        historyList.appendChild(listItem);
                    });
                } catch (error) {
                    console.error('更新历史记录UI失败:', error);
                }
            }

            /**
             * 显示Toast提示消息
             * @param {string} message - 要显示的消息
             * @param {string} type - 消息类型：'success' | 'error' | 'info' | 'warning'
             * @param {number} duration - 显示持续时间（毫秒），默认3000ms
             */
            function showToast(message, type = 'info', duration = 3000) {
                try {
                    // 移除现有的Toast
                    const existingToast = document.getElementById('inputMethodToast');
                    if (existingToast) {
                        existingToast.remove();
                    }
                    
                    // 创建Toast元素
                    const toast = document.createElement('div');
                    toast.id = 'inputMethodToast';
                    toast.className = `input-method-toast toast-${type}`;
                    
                    // 设置Toast内容
                    const toastContent = document.createElement('div');
                    toastContent.className = 'toast-content';
                    toastContent.textContent = message;
                    
                    // 添加图标（可选）
                    const toastIcon = document.createElement('span');
                    toastIcon.className = 'toast-icon';
                    
                    // 根据类型设置不同的图标
                    const iconMap = {
                        'success': '✓',
                        'error': '✗',
                        'warning': '⚠',
                        'info': 'ℹ'
                    };
                    toastIcon.textContent = iconMap[type] || iconMap.info;
                    
                    // 组装Toast
                    toast.appendChild(toastIcon);
                    toast.appendChild(toastContent);
                    
                    // 添加关闭按钮
                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'toast-close';
                    closeBtn.innerHTML = '&times;';
                    closeBtn.onclick = () => toast.remove();
                    toast.appendChild(closeBtn);
                    
                    // 添加到页面
                    document.body.appendChild(toast);
                    
                    // 添加显示动画
                    setTimeout(() => {
                        toast.classList.add('show');
                    }, 10);
                    
                    // 自动消失
                    if (duration > 0) {
                        setTimeout(() => {
                            if (toast.parentNode) {
                                toast.classList.remove('show');
                                setTimeout(() => {
                                    if (toast.parentNode) {
                                        toast.remove();
                                    }
                                }, 300); // 等待淡出动画完成
                            }
                        }, duration);
                    }
                } catch (error) {
                    console.error('显示Toast失败:', error);
                    // 降级方案：使用alert
                    alert(`${type.toUpperCase()}: ${message}`);
                }
            }

            /**
             * 显示错误消息（包装函数）
             * @param {string} message - 错误消息
             * @param {Error} error - 错误对象（可选）
             */
            function showErrorMessage(message, error = null) {
                console.error('输入法错误:', message, error);
                
                // 使用showToast显示错误消息
                showToast(`${message}${error ? ': ' + error.message : ''}`, 'error', 5000);
                
                // 同时在输出区域显示错误
                const outputArea = document.getElementById('output-area'); // Correct ID
                if (outputArea) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message';
                    errorDiv.innerHTML = `
                        <strong>错误:</strong> ${message}
                        ${error ? '<br><small>' + error.message + '</small>' : ''}
                    `;
                    outputArea.appendChild(errorDiv);
                }
            }

            /**
             * 显示加载消息
             * @param {string} message - 要显示的加载消息
             */
            function showLoadingMessage(message) {
                try {
                    const loadingOverlay = document.getElementById('loading-overlay');
                    const messageElement = loadingOverlay.querySelector('p');
                    
                    if (message) {
                        messageElement.textContent = message;
                    }
                    
                    loadingOverlay.style.display = 'flex';
                } catch (error) {
                    console.error('显示加载消息失败:', error);
                }
            }

            /**
             * 隐藏加载消息
             */
            function hideLoadingMessage() {
                try {
                    const loadingOverlay = document.getElementById('loading-overlay');
                    loadingOverlay.style.display = 'none';
                } catch (error) {
                    console.error('隐藏加载消息失败:', error);
                }
            }

            /**
             * 聚焦到隐藏输入框
             */
            function focusHiddenInput() {
                try {
                    const hInput = document.getElementById('hidden-input');
                    if (hInput) {
                        hInput.focus();
                    }
                } catch (error) {
                    console.error('聚焦隐藏输入框失败:', error);
                }
            }

            /**
             * 设置输入缓冲区
             * @param {string} value - 缓冲区值
             */
            function setBuffer(value) {
                buffer = value;
                const hInput = document.getElementById('hidden-input');
                if (hInput) {
                    hInput.value = value;
                }
            }

            /**
             * 进入修正模式
             */
            function enterCorrectionMode() {
                setState(InputState.CORRECTION);
                correctionWrapper.style.display = 'block';
                correctionInput.value = '';
                correctionInput.focus();
            }

            /**
             * 退出修正模式
             * @param {string} action - 退出动作类型
             */
            function exitCorrectionMode(action) {
                if (action === 'convert_sentence') {
                    const pinyinArray = correctionInput.value.trim().split(/\s+/);
                    if (pinyinArray.length > 0 && pinyinArray[0] !== '') {
                        // 这里需要实现拼音到汉字的转换逻辑
                        // 暂时简单处理：直接使用输入的拼音
                        committed += pinyinArray.join(' ');
                        showToast('已应用修正', 'success');
                    }
                }
                
                setState(InputState.NORMAL);
                correctionWrapper.style.display = 'none';
                update();
            }

            /**
             * 切换编辑模式
             */
            function toggleEditMode() {
                const isEditing = currentState === InputState.EDIT;
                setState(isEditing ? InputState.NORMAL : InputState.EDIT);
                
                const outputCard = document.getElementById('output-card');
                const editBtn = document.getElementById('edit-mode-btn');
                
                if (isEditing) {
                    outputCard.classList.remove('editing');
                    outputArea.classList.add('locked');
                    editBtn.textContent = '锁定模式';
                } else {
                    outputCard.classList.add('editing');
                    outputArea.classList.remove('locked');
                    editBtn.textContent = '编辑模式';
                }
            }

            /**
             * 归档并复制文本
             */
            function archiveAndCopy() {
                try {
                    if (committed.trim()) {
                        // 添加到历史记录
                        const historyItem = {
                            text: committed,
                            timestamp: Date.now()
                        };
                        HISTORY.unshift(historyItem);
                        localStorage.setItem("ime_history_v18", JSON.stringify(HISTORY));
                        
                        // 复制到剪贴板
                        navigator.clipboard.writeText(committed).then(() => {
                            showToast('已复制到剪贴板', 'success');
                            committed = "";
                            update();
                        }).catch(err => {
                            console.error('复制失败:', err);
                            showToast('复制失败', 'error');
                        });
                    } else {
                        showToast('没有内容可复制', 'warning');
                    }
                } catch (error) {
                    console.error('归档复制失败:', error);
                    showToast('操作失败', 'error');
                }
            }

            /**
             * 从编辑器同步内容
             */
            function syncFromEditor() {
                if (currentState === InputState.EDIT) {
                    committed = outputArea.textContent || '';
                }
            }

            /**
             * 切换练习模式
             */
            function togglePracticeMode() {
                const isPractice = currentState === InputState.PRACTICE;
                setState(isPractice ? InputState.NORMAL : InputState.PRACTICE);
                
                const practiceBtn = document.getElementById('practice-btn');
                
                if (isPractice) {
                    practiceBtn.classList.remove('active');
                    practiceTargetText = "";
                } else {
                    practiceBtn.classList.add('active');
                    generatePracticeText();
                }
                update();
            }

            /**
             * 生成练习文本
             */
            function generatePracticeText() {
                // 简单的练习文本生成逻辑
                const practiceWords = [
                    "你好，世界。",
                    "这是一个测试。",
                    "欢迎使用输入法。",
                    "练习模式已启动。"
                ];
                practiceTargetText = practiceWords[Math.floor(Math.random() * practiceWords.length)];
                committed = "";
                update();
            }

            /**
             * 切换历史记录面板
             */
            function toggleHistoryPanel() {
                const historyPanel = document.getElementById('historyPanel');
                const isVisible = historyPanel.style.display === 'block';
                historyPanel.style.display = isVisible ? 'none' : 'block';
                
                const histBtn = document.getElementById('l-hist-btn');
                histBtn.classList.toggle('active', !isVisible);
            }

            /**
             * 保存设置
             */
            function saveSettings() {
                localStorage.setItem("ime_settings", JSON.stringify(settings));
            }

            /**
             * 处理词典导入
             */
            function handleImportDict(fileInput) {
                if (!fileInput.files.length) return;
                
                const file = fileInput.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const dictData = JSON.parse(e.target.result);
                        const dictName = file.name.replace('.json', '');
                        
                        const newDict = {
                            name: dictName,
                            type: "user",
                            content: JSON.stringify(dictData),
                            enabled: true,
                            wordCount: calculateWordCount(dictData)
                        };
                        
                        allDicts.push(newDict);
                        saveDictConfig();
                        loadAllDicts().then(() => {
                            showToast(`已导入词典: ${dictName}`, 'success');
                            update();
                        });
                        
                    } catch (error) {
                        console.error('导入词典失败:', error);
                        showToast('导入失败，请检查文件格式', 'error');
                    }
                };
                
                reader.readAsText(file);
                fileInput.value = ''; // 重置文件输入
            }
            // --- End Missing function definitions ---

            // --- Init functions ---
            async function initInputHandler() {
                // Attach event listeners for hInput, correctionInput
                // Keep this minimal, actual logic handled by keydown/input listeners
                hInput.addEventListener("keydown", handleKeyDown);
                hInput.addEventListener("input", handleInput);
                correctionInput.addEventListener("keydown", handleCorrectionKeyDown);
            }

            function initUI() {
                // Initialize UI elements like outputArea, bufferDisplay, mainCandidates
                // Most of this is already done by direct DOM access, but this function
                // serves as a placeholder for more complex UI setup.
            }

            function initEventListeners() {
                // Global event listeners
                document.addEventListener("keydown", handleGlobalKeyDown);
                document.addEventListener("click", handleGlobalClick);
                document.addEventListener("visibilitychange", handleVisibilityChange);
            }
            // --- End Init functions ---


            const InputState = {
                NORMAL: 'normal',
                PRACTICE: 'practice',
                EDIT: 'edit',
                CORRECTION: 'correction',
                TAB: 'tab'
            };

            let currentState = InputState.NORMAL;
            function setState(newState) {
                currentState = newState;
                updateFocus();
            }

            function updateFocus() {
                if (currentState === InputState.EDIT) {
                    outputArea.focus();
                } else if (currentState === InputState.CORRECTION) {
                    correctionInput.focus();
                } else {
                    hInput.focus();
                }
            }
            
            const PUNCS = {
                ",": "，",
                ".": "。",
                "!": "！",
                "?": "？",
                ";": "；",
                ":": "：",
                "(": "（",
                ")": "）",
                "[": "【",
                "]": "】",
            };

            function getDictLevel(dict) {
                return typeof dict.level === "number" ? dict.level : 100; // Use 100 as per strong recommendation
            }

            class Trie {
                constructor() {
                    this.root = { children: {}, values: [] };
                }

                insert(key, value) {
                    let node = this.root;
                    for (const char of key) {
                        if (!node.children[char]) {
                            node.children[char] = { children: {}, values: [] };
                        }
                        node = node.children[char];
                    }
                    const items = Array.isArray(value) ? value : [value];
                    node.values.push(...items);
                }

                getNode(prefix) {
                    let node = this.root;
                    for (const char of prefix) {
                        if (!node.children[char]) return null;
                        node = node.children[char];
                    }
                    return node;
                }
            }

            let DB = new Trie();
            let allDicts = []; // This will now be loaded directly from localStorage

            let settings = JSON.parse(
                localStorage.getItem("ime_settings") || "{}",
            );
            if (!settings.outputHeight) settings.outputHeight = 300;
            if (typeof settings.history === "undefined")
                settings.history = true;
            if (!settings.practice_dicts) settings.practice_dicts = {};


            let activeLanguage = 'chinese';
            let buffer = "",
                committed = "",
                enFilter = "";
            let practiceTargetText = ""; // Moved practiceTargetText outside InputState logic

            let combinedCandidates = [],
                pageIndex = 0;
            const pageSize = 10; // Moved pageSize outside InputState logic
            let HISTORY = JSON.parse(
                localStorage.getItem("ime_history_v18") || "[]",
            );

            const hInput = document.getElementById("hidden-input");
            const outputArea = document.getElementById("output-area");
            const correctionWrapper =
                document.getElementById("correction-wrapper");
            const correctionInput = document.getElementById("correction-input");
            const mainCandidates = document.getElementById("main-candidates"); // Define mainCandidates


            async function init() {
                try {
                    console.log('开始初始化输入法...');
                    showLoadingMessage('正在初始化输入法...');
                    
                    // Core components setup
                    await Promise.all([
                        initInputHandler(),
                        initUI(),
                        initEventListeners()
                    ]);
                    
                    // Load settings and dictionaries
                    loadDictConfig(); // Load allDicts from localStorage or built-in
                    await loadAllDicts(); // Populate the Trie with enabled dicts

                    // Validate initialization
                    const isValid = validateInitialization();
                    if (!isValid) {
                        throw new Error('初始化验证失败');
                    }
                    
                    // Start input method
                    startInputMethod();
                    
                    console.log('输入法初始化完成');
                    hideLoadingMessage();
                    
                } catch (error) {
                    console.error('输入法初始化失败:', error);
                    showErrorMessage('输入法初始化失败，请刷新页面重试');
                    hideLoadingMessage();
                }
            }

            function validateInitialization() {
                const checks = [
                    {name: '隐藏输入框', check: () => !!document.getElementById('hidden-input')},
                    {name: '候选词区域', check: () => !!document.getElementById('main-candidates')},
                    {name: 'Trie树有数据', check: () => DB.root.children && Object.keys(DB.root.children).length > 0}
                ];
                
                for (const check of checks) {
                    if (!check.check()) {
                        console.error(`初始化检查失败: ${check.name}`);
                        return false;
                    }
                }
                
                return true;
            }

            // --- Missing function definitions (from gemini.md) ---
            /**
             * 增强的startInputMethod函数，包含历史记录初始化
             */
            function startInputMethod() {
                try {
                    console.log('启动输入法核心功能...');
                    
                    // 初始化历史记录
                    const savedHistory = localStorage.getItem('ime_input_history');
                    let historyItems = [];
                    
                    if (savedHistory) {
                        try {
                            historyItems = JSON.parse(savedHistory);
                            if (!Array.isArray(historyItems)) {
                                historyItems = [];
                            }
                        } catch (e) {
                            console.warn('历史记录解析失败，重置为空数组');
                            historyItems = [];
                        }
                    }
                    
                    // 更新历史记录UI
                    updateHistoryUI(historyItems);
                    
                    // 绑定历史记录保存
                    // This part needs to be integrated with existing commit logic
                    // For now, let's just make sure the updateHistoryUI is called
                    // on commit in the general update loop or dedicated commit function.
                    
                    // Set initial state and update UI
                    setState(InputState.NORMAL);
                    update();
                    
                    // 显示启动成功消息
                    showToast('输入法启动成功', 'success', 2000);
                    console.log('输入法启动完成');
                    
                } catch (error) {
                    console.error('启动输入法失败:', error);
                    showErrorMessage('启动输入法失败', error);
                }
            }
            // --- End Missing function definitions ---


            function showErrorMessage(message, error = null) {
                console.error('输入法错误:', message, error);
                showToast(`${message}${error ? ': ' + error.message : ''}`, 'error', 5000);
            }

            // This function now only retrieves allDicts from localStorage and ensures it's initialized
            function loadDictConfig() {
                const storedDicts = JSON.parse(
                    localStorage.getItem("ime_dicts_config"),
                );
                if (storedDicts && storedDicts.length > 0) { // Check if storedDicts is not empty
                    allDicts = storedDicts;
                    // Add any new built-in dicts that aren't already in stored config
                    BUILT_IN_DICTS.forEach((builtInDict) => {
                        if (
                            !allDicts.find((d) => d.path === builtInDict.path && d.type === builtInDict.type)
                        ) {
                            allDicts.push(builtInDict);
                        }
                    });
                } else {
                    allDicts = [...BUILT_IN_DICTS];
                }
                
                // Initialize practice dicts settings for newly added dicts if not present
                allDicts.forEach((dict, index) => {
                    if (settings.practice_dicts[index] === undefined) {
                        settings.practice_dicts[index] = false; // Default to not selected for practice
                    }
                });
                // No saveDictConfig here, as this is just loading initial state
            }

            function saveDictConfig() {
                localStorage.setItem(
                    "ime_dicts_config",
                    JSON.stringify(allDicts),
                );
                saveSettings(); // Ensure global settings are saved too
            }


            function calculateWordCount(dictContent) {
                let count = 0;
                for (const k in dictContent) {
                    count += Array.isArray(dictContent[k])
                        ? dictContent[k].length
                        : 1;
                }
                return count;
            }

            async function loadAllDicts() {
                DB = new Trie(); // Reset Trie before loading
                console.log("加载词典中...");
                
                const loadPromises = allDicts
                    .filter((d) => d.enabled) // Only load enabled dictionaries
                    .map((dict) => {
                        return new Promise(async (resolve) => {
                            try {
                                console.log(`尝试加载词典: ${dict.name} (enabled: ${dict.enabled})`);
                                let dictData;
                                if (dict.type === "built-in") {
                                    const response = await fetch(dict.path);
                                    if (!response.ok) {
                                        console.error(`无法加载内置词典 ${dict.name}: ${response.status}`);
                                        return resolve(); // Resolve even on error to allow other dicts to load
                                    }
                                    dictData = await response.json();
                                } else if (
                                    dict.type === "user" &&
                                    dict.content
                                ) {
                                    dictData = JSON.parse(dict.content);
                                }

                                if (dictData) {
                                    let currentWordCount = 0;
                                    for (const k in dictData) {
                                        const key = k.toLowerCase();
                                        const items = Array.isArray(dictData[k]) ? dictData[k] : [dictData[k]];
                                        DB.insert(key, items);
                                        currentWordCount += items.length;
                                    }
                                    dict.wordCount = currentWordCount; // Update wordCount directly on the dict object
                                }
                            } catch (e) {
                                console.error(
                                    "Failed to load or parse dict:",
                                    dict.name,
                                    e,
                                );
                            }
                            resolve();
                        });
                    });
                await Promise.all(loadPromises);
                console.log("所有启用的词典加载完成。");
            }

            function applySettings() {
                document.getElementById("output-card").style.height =
                    settings.outputHeight + "px";
                document.getElementById("historyPanel").style.display = // Corrected ID
                    settings.history ? "block" : "none"; // Changed to block/none for the panel
                document
                    .getElementById("l-hist-btn")
                    .classList.toggle("active", settings.history);
            }


            function update() {
                if (currentState === InputState.EDIT) return;

                if (currentState === InputState.PRACTICE && practiceTargetText) {
                    // New practice mode UI
                    const words = practiceTargetText.split('，').map(w => w.replace('。', ''));
                    let completedHTML = '';
                    let remainingHTML = '';
                    let currentWordIndex = -1;

                    let tempCommitted = committed;
                    for(let i=0; i<words.length; i++) {
                        if (tempCommitted.startsWith(words[i])) {
                            completedHTML += `<div class="practice-word completed">${escapeHtml(words[i])}</div>`;
                            tempCommitted = tempCommitted.substring(words[i].length);
                             if (tempCommitted.startsWith('，')) { // Handle separator
                                tempCommitted = tempCommitted.substring(1);
                            }
                        } else {
                            currentWordIndex = i;
                            break;
                        }
                    }

                    if (currentWordIndex !== -1) {
                         const currentWord = words[currentWordIndex];
                         let hasError = false;
                         if (!currentWord.startsWith(tempCommitted)) {
                            hasError = true;
                         }

                         const typedPart = tempCommitted;
                         const remainingPart = currentWord.substring(typedPart.length);

                         completedHTML += `<div class="practice-word ${hasError ? 'incorrect' : 'current'}">
                            ${escapeHtml(typedPart)}<span class="caret"></span><span class="practice-hint">${escapeHtml(remainingPart)}</span>
                        </div>`;
                         
                         for(let i=currentWordIndex+1; i<words.length; i++) {
                            remainingHTML += `<div class="practice-word upcoming">${escapeHtml(words[i])}</div>`;
                         }
                    } else { // All words committed successfully
                        if (committed.length >= practiceTargetText.length -1) { // -1 to account for final 。
                            setTimeout(() => {
                                committed = "";
                                generatePracticeText();
                                showToast("不错！下一组", 'success');
                            }, 200);
                        }
                    }


                    outputArea.innerHTML = `<div class="practice-words-container">${completedHTML}${remainingHTML}</div>`;

                } else {
                    outputArea.innerText = committed;
                }
                outputArea.scrollTop = outputArea.scrollHeight;

                if (buffer) {
                    const b = buffer.toLowerCase();
                    let bufferHTML = escapeHtml(b); // Display buffer as typed pinyin
                    if (currentState === InputState.TAB) {
                        bufferHTML += "-";
                        if (enFilter) {
                            bufferHTML += ` <span style="color: #ff9500;">${escapeHtml(enFilter)}</span>`;
                        }
                    }
                    document.getElementById("buffer-display").innerHTML = bufferHTML;
                    
                    let list = [];
                    const isAllVowels = (str) => /^[aeiou]+$/.test(str);

                    let useExactMatch = false;
                    if (b.length <= 2 || ((b.length === 3 || b.length === 4) && isAllVowels(b))) {
                        useExactMatch = true;
                    }
                    
                    const prefixNode = DB.getNode(b);

                    if (prefixNode) {
                        const collect = (node, path) => {
                            if (useExactMatch && path !== b) {
                                return;
                            }
                            if (node.values.length > 0) {
                                let weight = 1000;
                                if (path === b) weight += 10000; // Exact match bonus
                                weight -= (path.length - b.length) * 100;
                                
                                node.values.forEach((i) =>
                                    list.push({
                                        text: i.char || i,
                                        desc: i.en || (typeof i === "object" ? i.en : ""),
                                        w: weight,
                                    }),
                                );
                            }

                            if (!useExactMatch) {
                                for (const char in node.children) {
                                    collect(node.children[char], path + char);
                                }
                            }
                        };
                        collect(prefixNode, b);
                    }

                    const seen = new Set();
                    combinedCandidates = list
                        .sort((a, b) => b.w - a.w)
                        .filter((x) => !seen.has(x.text) && seen.add(x.text));

                    if (
                        b.length >= 6 &&
                        DB.getNode(b) &&
                        DB.getNode(b).values.length === 1 &&
                        currentState !== InputState.TAB
                    ) {
                        const word = combinedCandidates[0].text;
                        setTimeout(() => selectCandidate(word), 10);
                        return;
                    }
                } else {
                    document.getElementById("buffer-display").innerText = "";
                    combinedCandidates = [];
                }
                render();
            }

            function escapeHtml(text = "") {
                return String(text)
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            }

            function render() {
                let display = combinedCandidates;
                if (currentState === InputState.TAB && enFilter) {
                    display = combinedCandidates.filter(
                        (i) =>
                            i.desc &&
                            i.desc
                                .toLowerCase()
                                .startsWith(enFilter.toLowerCase()),
                    );
                    if (display.length === 1) {
                        selectCandidate(display[0].text);
                        return;
                    }
                }
                const totalPages = Math.ceil(display.length / pageSize);
                document.getElementById("page-counter").innerText =
                    buffer && display.length > 0
                        ? `${pageIndex + 1} / ${totalPages || 1}`
                        : "";
                const pageData = display.slice(
                    pageIndex * pageSize,
                    (pageIndex + 1) * pageSize,
                );
                document.getElementById("main-candidates").innerHTML = pageData
                    .map(
                        (item, i) => `
                    <div class="candidate-item" onclick="selectCandidate('${item.text}')">
                        <span class="cand-key">${(i + 1) % 10}</span><div class="cand-text">${item.text}</div>
                        ${item.desc ? `<div class="cand-desc">${item.desc}</div>` : ""}
                    </div>`,
                    )
                    .join("");
            }

            function selectCandidate(t) {
                committed += t;
                resetInput();
                update();
            }

            function resetInput() {
                setBuffer(""); // Consolidates buffer = "" and hInput.value = ""
                enFilter = "";
                setState(InputState.NORMAL); // Reset tab state
                pageIndex = 0;
            }

            function handleKeyDown(e) {
                if (currentState === InputState.EDIT || currentState === InputState.CORRECTION) return;
                const key = e.key;

                if (e.ctrlKey && key.toLowerCase() === "i") {
                    e.preventDefault();
                    enterCorrectionMode();
                    return;
                }

                if (PUNCS[key]) {
                    e.preventDefault();
                    if (buffer && combinedCandidates.length > 0)
                        committed += combinedCandidates[0].text;
                    committed += PUNCS[key];
                    resetInput();
                    update();
                    return;
                }

                if (buffer && currentState !== InputState.TAB) {
                    if (key === "=") {
                        e.preventDefault();
                        if (
                            (pageIndex + 1) * pageSize <
                            combinedCandidates.length
                        ) {
                            pageIndex++;
                            render();
                        }
                        return;
                    }
                    if (key === "-") {
                        e.preventDefault();
                        if (pageIndex > 0) {
                            pageIndex--;
                            render();
                        }
                        return;
                    }
                }

                if (key === "Tab") {
                    e.preventDefault();
                    if (buffer) {
                        setState(currentState === InputState.TAB ? InputState.NORMAL : InputState.TAB);
                        enFilter = "";
                        update();
                    }
                    return;
                }

                if (currentState === InputState.TAB && buffer) {
                    if (/^[a-zA-Z]$/.test(key)) {
                        e.preventDefault();
                        enFilter += key.toLowerCase();
                        pageIndex = 0;
                        render();
                        return;
                    }
                    if (key === "Backspace") {
                        e.preventDefault();
                        if (enFilter) {
                            enFilter = enFilter.slice(0, -1);
                            render();
                        } else {
                            setState(InputState.NORMAL);
                            update();
                        }
                        return;
                    }
                }

                if (/^[0-9]$/.test(key)) {
                    e.preventDefault();
                    if (buffer && combinedCandidates.length > 0) {
                        const idx = key === "0" ? 9 : parseInt(key) - 1;
                        const list =
                            currentState === InputState.TAB && buffer
                                ? combinedCandidates.filter(
                                      (c) =>
                                          c.desc &&
                                          c.desc
                                              .toLowerCase()
                                              .startsWith(enFilter),
                                  )
                                : combinedCandidates;
                        const pageData = list.slice(
                            pageIndex * pageSize,
                            (pageIndex + 1) * pageSize,
                        );
                        if (pageData[idx]) selectCandidate(pageData[idx].text);
                    } else if (!buffer) {
                        committed += key;
                        update();
                    }
                } else if (key === "Enter") {
                    e.preventDefault();
                    if (buffer) {
                        committed += buffer;
                        resetInput();
                    } else {
                        committed += "\n";
                    }
                    update();
                } else if (key === "Backspace") { // Handle backspace for both buffer and committed
                    e.preventDefault();
                    if (buffer) {
                        buffer = buffer.slice(0, -1);
                        hInput.value = buffer;
                        update();
                    } else if (committed) {
                        committed = committed.slice(0, -1);
                        update();
                    }
                } else if (key === " ") {
                    e.preventDefault();
                    if (buffer) {
                        const list =
                            currentState === InputState.TAB && buffer
                                ? combinedCandidates.filter(
                                      (c) =>
                                          c.desc &&
                                          c.desc
                                              .toLowerCase()
                                              .startsWith(enFilter),
                                  )
                                : combinedCandidates;
                        const pageData = list.slice(
                            pageIndex * pageSize,
                            (pageIndex + 1) * pageSize,
                        );
                        if (pageData[0]) selectCandidate(pageData[0].text);
                    } else {
                        committed += " ";
                        update();
                    }
                }
            }

            function handleInput() {
                if (currentState !== InputState.TAB && currentState !== InputState.EDIT) {
                    setBuffer(hInput.value.replace(/[^a-zA-Z]/g, ""));
                    pageIndex = 0;
                    update();
                }
            }

            function handleGlobalKeyDown(e) {
                const key = e.key.toLowerCase();
                if (e.ctrlKey && key === "e") {
                    e.preventDefault();
                    toggleEditMode();
                    return;
                }
                if (e.ctrlKey && key === "c") {
                    if (currentState !== InputState.EDIT && currentState !== InputState.CORRECTION) {
                        e.preventDefault();
                        archiveAndCopy();
                    }
                    return;
                }
                if (e.key === "escape") {
                    if (currentState === InputState.EDIT) setState(InputState.NORMAL);
                    if (currentState === InputState.CORRECTION) {
                        e.preventDefault();
                        exitCorrectionMode('update_buffer');
                    }
                }
            }

            function handleCorrectionKeyDown(e) {
                if (e.key === "Enter") {
                    e.preventDefault();
                    exitCorrectionMode('convert_sentence');
                } else if (e.key === "Escape") {
                    e.preventDefault();
                    exitCorrectionMode('update_buffer');
                } else if (e.ctrlKey && e.key.toLowerCase() === "i") {
                    e.preventDefault();
                    exitCorrectionMode('convert_sentence');
                }
            }

            function handleGlobalClick(e) {
                if (currentState === InputState.EDIT && outputArea.contains(e.target)) return;
                if (currentState === InputState.CORRECTION && correctionWrapper.contains(e.target))
                    return;
                // Clicking on import button is now handled by settings.html, remove from index.html
                // if (e.target.id === "file-uploader") return; 
                updateFocus(); // Keep focus where it should be based on state
            }

            function handleVisibilityChange() {
                if (!document.hidden) updateFocus(); // Restore focus on tab switch
            }

            function makeResizableV(id, targetId) {
                const h = document.getElementById(id),
                    t = document.getElementById(targetId);
                h.addEventListener("mousedown", (e) => {
                    const startY = e.clientY,
                        startH = t.offsetHeight;
                    const drag = (ev) => {
                        const newH = startH + (ev.clientY - startY);
                        t.style.height = newH + "px";
                        settings.outputHeight = newH;
                    };
                    const stop = () => {
                        document.removeEventListener("mousemove", drag);
                        saveSettings();
                    };
                    document.addEventListener("mousemove", drag);
                    document.addEventListener("mouseup", stop);
                });
            }

            document.addEventListener("DOMContentLoaded", () => {
                makeResizableV("center-v-resizer", "output-card");
                init();
            });
        </script>
    </body>
</html>
