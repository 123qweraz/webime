<!doctype html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>Web IME Pro | 导入与长句修正版</title>
        <script src="dicts_config.js"></script>
        <style>
            :root {
                --primary: #007aff;
                --bg: #f2f2f7;
                --panel-bg: #ffffff;
                --item-bg: #f9f9f9;
                --item-border: #eee;
                --github-dark: #24292e;
            }
            body {
                font-family: system-ui, sans-serif;
                background: var(--bg);
                margin: 0;
                padding: 15px;
                height: 100vh;
                display: flex;
                justify-content: center;
                overflow: hidden;
            }
            .main-layout {
                display: flex;
                flex-direction: column;
                gap: 15px;
                width: 100%;
                max-width: 1900px;
                height: 96vh;
            }
            .toolbar {
                background: var(--panel-bg);
                padding: 10px 20px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }
            .btn {
                padding: 6px 14px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 12px;
                transition: 0.2s;
                display: flex;
                align-items: center;
                gap: 5px;
            }
            .btn-toggle {
                background: #e5e5ea;
                color: #333;
            }
            .btn-toggle.active {
                background: var(--primary);
                color: white;
            }
            .btn-action {
                background: #34c759;
                color: white;
            }
            .btn-github {
                background: var(--github-dark);
                color: white;
                text-decoration: none;
                margin-left: auto;
            }
            .content-area {
                flex: 1;
                display: flex;
                gap: 15px;
                min-height: 0;
                position: relative;
            }
            .resizer {
                width: 6px;
                background: #ddd;
                cursor: col-resize;
                z-index: 10;
            }
            .resizer-v {
                height: 6px;
                background: #ddd;
                cursor: row-resize;
                z-index: 10;
                margin: 2px 0;
            }
            .history-panel {
                flex: 0 0 260px;
                background: #fff;
                border-radius: 16px;
                padding: 15px;
                display: flex;
                flex-direction: column;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            }
            .center-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-width: 400px;
                max-width: 1000px;
                margin: 0 auto;
            }
            .output-card {
                background: white;
                border-radius: 20px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
                position: relative;
                display: flex;
                flex-direction: column;
                min-height: 100px;
                border: 2px solid transparent;
                flex-grow: 2; /* Initial flex-grow for 2/5 height */
                flex-shrink: 0;
            }
            .output-card.editing {
                border: 2px solid #ff9500;
            }
            #output-area {
                flex: 1;
                padding: 25px;
                font-size: 24px;
                line-height: 1.6;
                word-break: break-all;
                white-space: pre-wrap;
                overflow-y: auto;
                outline: none;
            }
            .practice-hint {
                color: #d1d1d6;
                pointer-events: none;
            }
            .caret {
                display: inline-block;
                width: 2px;
                height: 1em;
                background: var(--primary);
                animation: blink 1s infinite;
                vertical-align: bottom;
            }

            .practice-char .caret {
                margin-left: 0;
            }

            #output-area.locked::after {
                content: "";
                display: inline-block;
                width: 2px;
                height: 28px;
                background: var(--primary);
                vertical-align: middle;
                margin-left: 2px;
                animation: blink 1s infinite;
            }
            @keyframes blink {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0;
                }
            }
            .control-group {
                position: absolute;
                right: 15px;
                bottom: 15px;
                display: flex;
                gap: 8px;
                z-index: 100;
            }
            .input-card {
                background: white;
                padding: 20px;
                border-radius: 20px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
                flex: 3; /* Initial flex-grow for 3/5 height */
                flex-shrink: 0;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                border: 3px solid transparent;
                position: relative;
            }
            .input-card.tab-mode {
                border-color: var(--primary);
                background: #f0f7ff;
            }
            .input-status-bar {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
                min-height: 30px;
            }
            #buffer-display {
                font-size: 18px;
                color: var(--primary);
                font-weight: bold;
                margin-bottom: 5px;
            }
            #main-candidates {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                min-height: 50px;
            }
            .candidate-item {
                position: relative;
                padding: 10px 15px;
                background: var(--item-bg);
                border-radius: 10px;
                cursor: pointer;
                font-size: 22px;
                font-weight: 500;
                border: 1px solid var(--item-border);
                transition: background-color 0.2s;
            }
            .candidate-item:hover {
                background-color: #e0e0e0;
            }
            .completion-item {
                position: relative;
                padding: 6px 10px;
                background: #e9e9eb;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 400;
                color: #555;
                border: 1px solid #ddd;
                transition: background-color 0.2s;
                margin-bottom: 5px; /* Add some space between completion items */
            }
            .completion-item:hover {
                background-color: #d8d8da;
            }
            .completion-header {
                font-size: 14px;
                color: #888;
                margin-top: 10px;
                margin-bottom: 5px;
                border-bottom: 1px solid #eee;
                padding-bottom: 3px;
            }
            .cand-key {
                position: absolute;
                top: 2px;
                left: 4px;
                font-size: 10px;
                opacity: 0.5;
                color: var(--primary);
                font-weight: bold;
            }
            #hidden-input {
                position: fixed;
                left: -999px;
                opacity: 0;
            }

            #correction-wrapper {
                position: absolute;
                bottom: 20px;
                left: 20px;
                right: 20px;
                background: white;
                box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
                border-radius: 12px;
                padding: 15px;
                display: none;
                z-index: 200;
                border: 2px solid var(--primary);
            }
            #correction-input {
                width: 100%;
                font-size: 20px;
                border: none;
                outline: none;
                font-family: system-ui;
                color: #333;
                font-weight: 500;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
            }
            .correction-tip {
                font-size: 12px;
                color: #888;
                margin-top: 8px;
                display: flex;
                justify-content: space-between;
            }

            #toast {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #333;
                color: white;
                padding: 8px 20px;
                border-radius: 20px;
                opacity: 0;
                transition: 0.3s;
                z-index: 999;
                pointer-events: none;
            }
            #file-uploader {
                display: none;
            }
            .history-panel {
                flex: 0 0 260px; /* Maintain initial width, allow it to be a flex item */
                height: 100%; /* Take full height of content-area */
                background: #fff;
                border-radius: 16px;
                padding: 15px;
                display: flex; /* Changed from 'none' to 'flex' for flex layout */
                flex-direction: column;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
                z-index: 1000;
                overflow: hidden;
                margin-right: 15px; /* Add some spacing to the right */
            }
            .history-header {
                padding: 12px 16px;
                background: #f5f5f5;
                border-bottom: 1px solid #ddd;
                font-weight: bold;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .history-list {
                list-style: none;
                padding: 0;
                margin: 0;
                max-height: 350px;
                overflow-y: auto;
            }
            .history-item {
                padding: 10px 16px;
                border-bottom: 1px solid #f0f0f0;
                cursor: pointer;
                transition: background 0.2s;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .history-item:hover {
                background: #f8f8f8;
            }
            .history-item.empty {
                color: #999;
                cursor: default;
            }
            .history-item.empty:hover {
                background: transparent;
            }
            .history-time {
                font-size: 12px;
                color: #666;
                min-width: 50px;
            }
            .history-text {
                flex: 1;
                margin-left: 10px;
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
            }
            .history-delete-btn {
                background: none;
                border: none;
                color: #cc0000;
                font-size: 18px;
                cursor: pointer;
                padding: 0 5px;
                margin-left: 10px;
                opacity: 0.6;
                transition: opacity 0.2s;
            }
            .history-delete-btn:hover {
                opacity: 1;
            }
            .input-method-toast {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: #333;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 9999;
                display: flex;
                align-items: center;
                gap: 10px;
                opacity: 0;
                transform: translateY(20px);
                transition:
                    opacity 0.3s,
                    transform 0.3s;
                max-width: 300px;
                font-size: 14px;
            }
            .input-method-toast.show {
                opacity: 1;
                transform: translateY(0);
            }
            .toast-success {
                background: #4caf50;
                border-left: 4px solid #2e7d32;
            }
            .toast-error {
                background: #f44336;
                border-left: 4px solid #c62828;
            }
            .toast-warning {
                background: #ff9800;
                border-left: 4px solid #ef6c00;
            }
            .toast-info {
                background: #2196f3;
                border-left: 4px solid #1565c0;
            }
            .toast-icon {
                font-weight: bold;
                font-size: 16px;
            }
            .toast-content {
                flex: 1;
            }
            .toast-close {
                background: transparent;
                border: none;
                color: white;
                font-size: 18px;
                cursor: pointer;
                padding: 0 5px;
                opacity: 0.7;
                transition: opacity 0.2s;
            }
            .toast-close:hover {
                opacity: 1;
            }
            #loading-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 255, 255, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                flex-direction: column;
                z-index: 1000;
                font-size: 24px;
                color: var(--primary);
                display: none; /* Hidden by default */
            }
            #loading-spinner {
                border: 4px solid #f3f3f3;
                border-top: 4px solid var(--primary);
                border-radius: 50%;
                width: 40px;
                height: 40px;
                animation: spin 1s linear infinite;
                margin-bottom: 20px;
            }
            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }
            /* New Modal Styles */
            .modal-overlay {
                position: fixed;
                top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.4);
                backdrop-filter: blur(4px);
                z-index: 1000;
                display: flex; align-items: center; justify-content: center;
            }
            .modal-content {
                background: white;
                width: 90%; max-width: 500px;
                max-height: 80vh;
                border-radius: 16px;
                padding: 20px;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            }
            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
                padding-bottom: 10px;
                border-bottom: 1px solid #eee;
            }
            .modal-header h3 {
                margin: 0;
                font-size: 24px;
                color: #333;
                border-bottom: 2px solid var(--primary);
                padding-bottom: 10px;
            }
            .modal-header button {
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #999;
            }
            .import-section {
                margin-bottom: 20px;
                padding-bottom: 15px;
                border-bottom: 1px solid #eee;
            }
            .modal-controls {
                margin-bottom: 20px;
                display: flex;
                gap: 10px;
            }
            .dict-sections h4 {
                margin-top: 20px;
                margin-bottom: 10px;
                color: #555;
            }
            .dict-list {
                min-height: 50px;
                border: 1px dashed #ccc;
                border-radius: 8px;
                margin-bottom: 20px;
                padding: 10px;
                background: #f9f9f9;
            }
            .dict-card {
                background: #f5f5f7;
                padding: 10px;
                margin: 5px 0;
                border-radius: 8px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            }
            .dict-card.disabled {
                opacity: 0.6;
                background: #e0e0e0;
            }
            .dict-card-name {
                flex-grow: 1;
                font-weight: 500;
                color: #333;
            }
            .dict-card-actions {
                display: flex; /* Make buttons arrange horizontally */
                gap: 8px; /* Add some space between buttons */
                align-items: center; /* Vertically align buttons */
            }
            .dict-card-actions button {
                background: none;
                border: none;
                font-size: 16px;
                cursor: pointer;
                color: var(--primary);
            }
            .dict-card-actions button.toggle-off {
                color: #ccc;
            }
            .dict-card-actions button.delete {
                color: #cc0000;
            }
        </style>
    </head>
    <body>
        <div class="main-layout">
            <div class="toolbar">
                <button
                    id="l-hist-btn"
                    class="btn btn-toggle"
                    onclick="toggleHistoryPanel()"
                >
                    历史记录
                </button>
                <div
                    style="
                        width: 1px;
                        height: 20px;
                        background: #ddd;
                        margin: 0 5px;
                    "
                ></div>
                <a href="hanzi_explorer.html" class="btn btn-toggle"
                    >汉字浏览器</a
                >
                <a
                    href="https://github.com/123qweraz/webime"
                    target="_blank"
                    class="btn btn-github"
                    >GitHub Star</a
                >
                <button class="btn btn-toggle" onclick="openDictModal()">
                    词典设置
                </button>
            </div>
            <div class="content-area">
                <div class="history-panel" id="historyPanel">
                    <div class="history-header">
                        <span>输入历史</span>
                        <button
                            onclick="clearHistory()"
                            class="btn btn-toggle"
                            style="
                                margin-left: auto;
                                margin-right: 5px;
                                font-size: 10px;
                                padding: 4px 8px;
                            "
                        >
                            清空
                        </button>
                    </div>
                    <ul id="historyList" class="history-list"></ul>
                </div>
                <div class="resizer" id="left-resizer"></div>
                <div class="center-container">
                    <div class="output-card" id="output-card">
                        <div
                            id="output-area"
                            class="locked"
                            spellcheck="false"
                            oninput="syncFromEditor()"
                        ></div>
                        <div class="control-group">
                            <button
                                id="edit-mode-btn"
                                class="btn btn-toggle"
                                onclick="toggleEditMode()"
                            >
                                锁定模式
                            </button>
                            <button
                                class="btn btn-toggle active"
                                style="background: #222"
                                onclick="archiveAndCopy()"
                            >
                                归档并复制
                            </button>
                        </div>
                    </div>
                    <div class="resizer-v" id="center-v-resizer"></div>
                    <div
                        class="input-card"
                        id="input-container"
                        onclick="focusHiddenInput()"
                    >
                        <div class="input-status-bar">
                            <div id="buffer-display"></div>
                            <div id="page-counter"></div>
                        </div>
                        <div id="main-candidates"></div>

                        <div id="correction-wrapper">
                            <input
                                type="text"
                                id="correction-input"
                                autocomplete="off"
                                placeholder="输入拼音短语，用空格分隔，如: ni hao"
                            />
                            <div class="correction-tip">
                                <span>支持长句输入 (空格分隔)</span>
                                <span>Enter 上屏 / Esc 取消</span>
                            </div>
                        </div>

                        <input
                            type="text"
                            id="hidden-input"
                            autocomplete="off"
                        />
                    </div>
                </div>
            </div>
        </div>
        <div id="loading-overlay">
            <div id="loading-spinner"></div>
            <p>正在初始化输入法...</p>
        </div>
        <div id="toast"></div>

        <div id="dict-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>词典管理</h3>
                    <button onclick="closeDictModal()">✕</button>
                </div>
                <div class="modal-body">
                    <div class="import-section">
                        <input type="file" id="dict-file-input" style="display:none" onchange="handleImport(this)">
                        <button class="btn" onclick="document.getElementById('dict-file-input').click()">导入新词典 (.json)</button>
                    </div>

                    <div class="modal-controls">
                        <button class="btn btn-toggle" onclick="sortDictsByDefaultOrder()">中文</button>
                    </div>
                    
                    <div class="dict-sections">
                        <h4>已启用 (拖拽排序)</h4>
                        <div id="modal-active-list" class="dict-list"></div>
                        
                        <h4>未启用</h4>
                        <div id="modal-inactive-list" class="dict-list"></div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // Dictionary Modal Functions
            function openDictModal() {
                document.getElementById('dict-modal').style.display = 'flex';
                renderModalDicts(); // Render dictionaries when modal opens
            }

            function closeDictModal() {
                document.getElementById('dict-modal').style.display = 'none';
            }

            function renderModalDicts() {
                const activeList = document.getElementById('modal-active-list');
                const inactiveList = document.getElementById('modal-inactive-list');
                activeList.innerHTML = '';
                inactiveList.innerHTML = '';

                allDicts.forEach((dict, index) => {
                    const dictCard = document.createElement('div');
                    dictCard.className = `dict-card ${!dict.enabled ? 'disabled' : ''}`;
                    dictCard.setAttribute('data-index', index);
                    dictCard.setAttribute('draggable', 'true'); // Make draggable
                    dictCard.setAttribute('tabindex', '0'); // Make focusable for keyboard navigation

                    dictCard.addEventListener('dragstart', (e) => {
                        draggedDictIndex = index;
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', index); // Set data for Firefox
                        setTimeout(() => dictCard.style.opacity = '0.5', 0); // Hide dragged item
                    });

                    dictCard.addEventListener('dragover', (e) => {
                        e.preventDefault(); // Allow drop
                        const targetCard = e.currentTarget;
                        if (draggedDictIndex !== null && draggedDictIndex !== index) {
                            const bounding = targetCard.getBoundingClientRect();
                            const offset = bounding.y + (bounding.height / 2);
                            if (e.clientY < offset) {
                                targetCard.style.borderTop = '2px solid var(--primary)';
                                targetCard.style.borderBottom = '';
                            } else {
                                targetCard.style.borderBottom = '2px solid var(--primary)';
                                targetCard.style.borderTop = '';
                            }
                        }
                    });

                    dictCard.addEventListener('dragleave', (e) => {
                        e.currentTarget.style.borderTop = '';
                        e.currentTarget.style.borderBottom = '';
                    });

                    dictCard.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.currentTarget.style.borderTop = '';
                        e.currentTarget.style.borderBottom = '';
                        if (draggedDictIndex !== null && draggedDictIndex !== index) {
                            const droppedOnIndex = index;
                            const isBefore = e.clientY < e.currentTarget.getBoundingClientRect().y + (e.currentTarget.getBoundingClientRect().height / 2);
                            handleDictDrop(draggedDictIndex, droppedOnIndex, isBefore);
                        }
                    });

                    dictCard.addEventListener('dragend', (e) => {
                        e.target.style.opacity = '1'; // Restore opacity
                        draggedDictIndex = null;
                        document.querySelectorAll('.dict-card').forEach(card => {
                            card.style.borderTop = '';
                            card.style.borderBottom = '';
                        });
                    });

                    dictCard.addEventListener('keydown', (e) => handleDictCardKeyDown(index, e));

                    dictCard.innerHTML = `
                        <span class="dict-card-name">${dict.name} (${dict.wordCount || 0} 词)</span>
                        <div class="dict-card-actions">
                            <button class="btn btn-sm move-up-btn" onclick="moveDictUp(${index})" ${index === 0 ? 'disabled' : ''}>↑</button>
                            <button class="btn btn-sm move-down-btn" onclick="moveDictDown(${index})" ${index === allDicts.length - 1 ? 'disabled' : ''}>↓</button>
                            <button class="btn btn-sm toggle-btn ${dict.enabled ? 'toggle-on' : 'toggle-off'}" onclick="toggleDictStatus(${index})">
                                ${dict.enabled ? '禁用' : '启用'}
                            </button>
                            ${dict.type !== 'built-in' ? `<button class="btn btn-sm delete-btn" onclick="deleteDict(${index})">删除</button>` : ''}
                        </div>
                    `;

                    if (dict.enabled) {
                        activeList.appendChild(dictCard);
                    } else {
                        inactiveList.appendChild(dictCard);
                    }
                });
            }

            async function sortDictsByDefaultOrder() {
                const desiredOrder = ["基础词典", "词组词典", "二级字", "三级字", "四字词"];
                
                // First, enable all dictionaries that are part of the desired order
                allDicts.forEach(dict => {
                    if (desiredOrder.includes(dict.name)) {
                        dict.enabled = true;
                    }
                });

                allDicts.sort((a, b) => {
                    const indexA = desiredOrder.indexOf(a.name);
                    const indexB = desiredOrder.indexOf(b.name);

                    // If both are in desiredOrder, sort by their index
                    if (indexA !== -1 && indexB !== -1) {
                        return indexA - indexB;
                    }
                    // If only 'a' is in desiredOrder, 'a' comes first
                    if (indexA !== -1) {
                        return -1;
                    }
                    // If only 'b' is in desiredOrder, 'b' comes first
                    if (indexB !== -1) {
                        return 1;
                    }
                    // If neither is in desiredOrder, maintain current relative order (or sort by name as a fallback)
                    return a.name.localeCompare(b.name);
                });
                
                saveDictConfig();
                await loadAllDicts();
                renderModalDicts();
                showToast('中文词典已启用并排序', 'info');
            }

            let draggedDictIndex = null; // Global variable to store the index of the dictionary being dragged

            async function handleDictDrop(draggedIndex, droppedOnIndex, isBefore) {
                // If dragged and dropped on the same item, or if the indices are invalid, do nothing
                if (draggedIndex === droppedOnIndex || draggedIndex < 0 || droppedOnIndex < 0 || draggedIndex >= allDicts.length || droppedOnIndex >= allDicts.length) {
                    return;
                }

                const [movedDict] = allDicts.splice(draggedIndex, 1);
                let targetIndex = droppedOnIndex;

                if (draggedIndex < droppedOnIndex) {
                    // Item was dragged downwards
                    if (isBefore) {
                        // Dropped before the target, so new index is target - 1
                        targetIndex = droppedOnIndex - 1;
                    } else {
                        // Dropped after the target, new index is target
                        targetIndex = droppedOnIndex;
                    }
                } else {
                    // Item was dragged upwards
                    if (isBefore) {
                        // Dropped before the target, new index is target
                        targetIndex = droppedOnIndex;
                    } else {
                        // Dropped after the target, new index is target + 1
                        targetIndex = droppedOnIndex + 1;
                    }
                }
                
                // Ensure targetIndex is within valid bounds
                targetIndex = Math.max(0, Math.min(targetIndex, allDicts.length));

                allDicts.splice(targetIndex, 0, movedDict);
                saveDictConfig();
                await loadAllDicts();
                renderModalDicts();
                showToast(`词典 "${movedDict.name}" 已移动`, 'info');
            }

            async function handleDictCardKeyDown(index, event) {
                if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    if (index > 0) {
                        const [movedDict] = allDicts.splice(index, 1);
                        allDicts.splice(index - 1, 0, movedDict);
                        saveDictConfig();
                        await loadAllDicts();
                        renderModalDicts();
                        // Refocus the moved element
                        requestAnimationFrame(() => {
                            const newCard = document.querySelector(`.dict-card[data-index="${index - 1}"]`);
                            if (newCard) newCard.focus();
                        });
                        showToast(`词典 "${movedDict.name}" 上移`, 'info');
                    }
                } else if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    if (index < allDicts.length - 1) {
                        const [movedDict] = allDicts.splice(index, 1);
                        allDicts.splice(index + 1, 0, movedDict);
                        saveDictConfig();
                        await loadAllDicts();
                        renderModalDicts();
                        // Refocus the moved element
                        requestAnimationFrame(() => {
                            const newCard = document.querySelector(`.dict-card[data-index="${index + 1}"]`);
                            if (newCard) newCard.focus();
                        });
                        showToast(`词典 "${movedDict.name}" 下移`, 'info');
                    }
                }
            }
            async function toggleDictStatus(index) {
                if (allDicts[index]) {
                    allDicts[index].enabled = !allDicts[index].enabled;
                    saveDictConfig(); // Save changes to localStorage
                    await loadAllDicts(); // Reload Trie to reflect changes
                    renderModalDicts(); // Re-render modal to show updated status
                }
            }

            async function moveDictUp(index) {
                if (index > 0) {
                    const [movedDict] = allDicts.splice(index, 1); // Remove from current position
                    allDicts.splice(index - 1, 0, movedDict); // Insert at new position
                    saveDictConfig(); // Save changes
                    await loadAllDicts(); // Reload Trie
                    renderModalDicts(); // Re-render modal
                }
            }

            async function moveDictDown(index) {
                if (index < allDicts.length - 1) {
                    const [movedDict] = allDicts.splice(index, 1); // Remove from current position
                    allDicts.splice(index + 1, 0, movedDict); // Insert at new position
                    saveDictConfig(); // Save changes
                    await loadAllDicts(); // Reload Trie
                    renderModalDicts(); // Re-render modal
                }
            }

            async function deleteDict(index) {
                if (allDicts[index].type === 'built-in') {
                    showToast('无法删除内置词典', 'warning');
                    return;
                }
                if (allDicts[index] && confirm(`确定要删除词典 "${allDicts[index].name}" 吗？`)) {
                    allDicts.splice(index, 1); // Remove from array
                    saveDictConfig(); // Save changes
                    await loadAllDicts(); // Reload Trie
                    renderModalDicts(); // Re-render modal
                }
            }

            // Function for handling dictionary import from the modal
            /**
             * 更新历史记录UI显示
             * @param {Array} historyItems - 历史记录条目数组
             */
            function updateHistoryUI(historyItems) {
                try {
                    const historyList = document.getElementById("historyList");
                    if (!historyList) {
                        console.warn("历史记录容器元素未找到");
                        return;
                    }

                    // 清空现有内容
                    historyList.innerHTML = "";

                    // 如果没有历史记录，显示提示
                    if (!historyItems || historyItems.length === 0) {
                        const emptyItem = document.createElement("li");
                        emptyItem.className = "history-item empty";
                        emptyItem.textContent = "暂无输入历史";
                        historyList.appendChild(emptyItem);
                        return;
                    }

                    // 显示最近的历史记录（最多20条）
                    const recentItems = historyItems.slice(0, 20);

                    recentItems.forEach((item, index) => {
                        const listItem = document.createElement("li");
                        listItem.className = "history-item";

                        const timeSpan = document.createElement("span");
                        timeSpan.className = "history-time";

                        if (item.timestamp) {
                            const date = new Date(item.timestamp);
                            timeSpan.textContent = date.toLocaleTimeString([], {
                                hour: "2-digit",
                                minute: "2-digit",
                            });
                        } else {
                            timeSpan.textContent = "刚刚";
                        }

                        const textSpan = document.createElement("span");
                        textSpan.className = "history-text";
                        textSpan.textContent = item.text || item;

                        // Delete button
                        const deleteButton = document.createElement("button");
                        deleteButton.textContent = "×";
                        deleteButton.className = "history-delete-btn";
                        deleteButton.onclick = (event) => {
                            event.stopPropagation(); // Prevent listItem click event
                            deleteHistoryItem(index);
                        };

                        listItem.appendChild(timeSpan);
                        listItem.appendChild(textSpan);
                        listItem.appendChild(deleteButton);

                        // Clicking history item to fill input
                        listItem.addEventListener("click", () => {
                            const inputElement =
                                document.getElementById("hidden-input");
                            if (
                                inputElement &&
                                inputElement.value !== undefined
                            ) {
                                inputElement.value = item.text || item;
                                const inputEvent = new Event("input", {
                                    bubbles: true,
                                });
                                inputElement.dispatchEvent(inputEvent);

                            }
                        });

                        historyList.appendChild(listItem);
                    });
                } catch (error) {
                    console.error("更新历史记录UI失败:", error);
                }
            }

            /**
             * 显示Toast提示消息
             * @param {string} message - 要显示的消息
             * @param {string} type - 消息类型：'success' | 'error' | 'info' | 'warning'
             * @param {number} duration - 显示持续时间（毫秒），默认3000ms
             */
            function showToast(message, type = "info", duration = 3000) {
                try {
                    // 移除现有的Toast
                    const existingToast =
                        document.getElementById("inputMethodToast");
                    if (existingToast) {
                        existingToast.remove();
                    }

                    // 创建Toast元素
                    const toast = document.createElement("div");
                    toast.id = "inputMethodToast";
                    toast.className = `input-method-toast toast-${type}`;

                    // 设置Toast内容
                    const toastContent = document.createElement("div");
                    toastContent.className = "toast-content";
                    toastContent.textContent = message;

                    // 添加图标（可选）
                    const toastIcon = document.createElement("span");
                    toastIcon.className = "toast-icon";

                    // 根据类型设置不同的图标
                    const iconMap = {
                        success: "✓",
                        error: "✗",
                        warning: "⚠",
                        info: "ℹ",
                    };
                    toastIcon.textContent = iconMap[type] || iconMap.info;

                    // 组装Toast
                    toast.appendChild(toastIcon);
                    toast.appendChild(toastContent);

                    // 添加关闭按钮
                    const closeBtn = document.createElement("button");
                    closeBtn.className = "toast-close";
                    closeBtn.innerHTML = "&times;";
                    closeBtn.onclick = () => toast.remove();
                    toast.appendChild(closeBtn);

                    // 添加到页面
                    document.body.appendChild(toast);

                    // 添加显示动画
                    setTimeout(() => {
                        toast.classList.add("show");
                    }, 10);

                    // 自动消失
                    if (duration > 0) {
                        setTimeout(() => {
                            if (toast.parentNode) {
                                toast.classList.remove("show");
                                setTimeout(() => {
                                    if (toast.parentNode) {
                                        toast.remove();
                                    }
                                }, 300); // 等待淡出动画完成
                            }
                        }, duration);
                    }
                } catch (error) {
                    console.error("显示Toast失败:", error);
                    // 降级方案：使用alert
                    alert(`${type.toUpperCase()}: ${message}`);
                }
            }

            /**
             * 显示错误消息（包装函数）
             * @param {string} message - 错误消息
             * @param {Error} error - 错误对象（可选）
             */
            function showErrorMessage(message, error = null) {
                console.error("输入法错误:", message, error);

                // 使用showToast显示错误消息
                showToast(
                    `${message}${error ? ": " + error.message : ""}`,
                    "error",
                    5000,
                );

                // 同时在输出区域显示错误
                const outputArea = document.getElementById("output-area"); // Correct ID
                if (outputArea) {
                    const errorDiv = document.createElement("div");
                    errorDiv.className = "error-message";
                    errorDiv.innerHTML = `
                        <strong>错误:</strong> ${message}
                        ${error ? "<br><small>" + error.message + "</small>" : ""}
                    `;
                    outputArea.appendChild(errorDiv);
                }
            }

            /**
             * 显示加载消息
             * @param {string} message - 要显示的加载消息
             */
            function showLoadingMessage(message) {
                try {
                    const loadingOverlay =
                        document.getElementById("loading-overlay");
                    const messageElement = loadingOverlay.querySelector("p");

                    if (message) {
                        messageElement.textContent = message;
                    }

                    loadingOverlay.style.display = "flex";
                } catch (error) {
                    console.error("显示加载消息失败:", error);
                }
            }

            /**
             * 隐藏加载消息
             */
            function hideLoadingMessage() {
                try {
                    const loadingOverlay =
                        document.getElementById("loading-overlay");
                    loadingOverlay.style.display = "none";
                } catch (error) {
                    console.error("隐藏加载消息失败:", error);
                }
            }

            /**
             * 聚焦到隐藏输入框
             */
            function focusHiddenInput() {
                try {
                    const hInput = document.getElementById("hidden-input");
                    if (hInput) {
                        hInput.focus();
                    }
                } catch (error) {
                    console.error("聚焦隐藏输入框失败:", error);
                }
            }

            /**
             * 设置输入缓冲区
             * @param {string} value - 缓冲区值
             */
            function setBuffer(value) {
                buffer = value;
                const hInput = document.getElementById("hidden-input");
                if (hInput) {
                    hInput.value = value;
                }
            }

            /**
             * 将拼音字符串转换为汉字。
             * 目前只取每个拼音的第一个候选词。
             * @param {string} pinyinString - 以空格分隔的拼音字符串 (e.g., "ni hao")
             * @returns {string} 转换后的汉字字符串
             */
            function convertPinyinToHanzi(pinyinString) {
                const pinyinSegments = pinyinString.trim().split(/\s+/);
                let hanziResult = [];

                for (const segment of pinyinSegments) {
                    if (!segment) continue;

                    const node = DB.getNode(segment.toLowerCase());
                    let foundHanzi = null;

                    if (node && node.values.length > 0) {
                        // Assuming the first value is the most relevant or a good default
                        // In a more advanced IME, this would involve ranking or user selection
                        foundHanzi = node.values[0].char || node.values[0];
                    }

                    hanziResult.push(foundHanzi || segment); // Fallback to pinyin if no Hanzi found
                }
                return hanziResult.join("");
            }

            /**
             * 进入修正模式
             */
            function enterCorrectionMode() {
                setState(InputState.CORRECTION);
                correctionWrapper.style.display = 'block';
                correctionInput.value = buffer; // Sync In: Fill with current buffer
                correctionInput.focus();
            }

            /**
             * 退出修正模式
             * @param {string} action - 退出动作类型
             */
            function exitCorrectionMode(action) {
                                                                if (action === "convert_sentence") {
                                                                    const pinyinPhrase = correctionInput.value.trim();
                                                                    if (pinyinPhrase) {
                                                                        const convertedHanzi =
                                                                            convertPinyinToHanzi(pinyinPhrase);
                                                                        committed += convertedHanzi;
                                                                    }
                                                                    // Clear the main buffer after committing from correction mode
                                                                    setBuffer(""); 
                                                                                                } else if (action === 'sync_out_buffer') { // New logic for sync-out
                                                                                                    const correctedText = correctionInput.value.trim();
                                                                                                    setBuffer(correctedText); // Update global buffer and hInput.value
                                                                                                    pageIndex = 0; // Reset page index
                                                                                                    setTimeout(() => update(), 0); // Add a small delay for UI refresh
                                                                                                    // Removed 'return;' here to allow subsequent state changes
                                                                                                }
                                                                                                
                                                                                                setState(InputState.NORMAL);
                                                                                                correctionWrapper.style.display = "none";
                                                                                                update();            }

            /**
             * 切换编辑模式
             */
            function toggleEditMode() {
                const isEditing = currentState === InputState.EDIT;
                setState(isEditing ? InputState.NORMAL : InputState.EDIT);

                const outputCard = document.getElementById("output-card");
                const editBtn = document.getElementById("edit-mode-btn");

                if (isEditing) {
                    outputCard.classList.remove("editing");
                    outputArea.classList.add("locked");
                    outputArea.contentEditable = false; // Disable contenteditable
                    editBtn.textContent = "锁定模式";
                } else {
                    outputCard.classList.add("editing");
                    outputArea.classList.remove("locked");
                    outputArea.contentEditable = true; // Enable contenteditable
                    editBtn.textContent = "编辑模式";
                }
            }

                        /**

                         * 归档并复制文本

                         */

                        function archiveAndCopy() {

                            try {

                                if (committed.trim()) {

                                    // History is now managed by resetInput()

                                    // No need to add to history here explicitly for committed text

                                    // Just copy to clipboard and clear committed.

            

                                    // 复制到剪贴板

                                    navigator.clipboard

                                        .writeText(committed)

                                        .then(() => {

                                            committed = "";

                                            update();

                                        })

                                        .catch((err) => {

                                            console.error("复制失败:", err);

                                            showToast("复制失败", "error");

                                        });

                                } else {

                                    showToast("没有内容可复制", "warning");

                                }

                            } catch (error) {

                                console.error("归档复制失败:", error);

                                showToast("操作失败", "error");

                            }

                        }

            /**
             * 从编辑器同步内容
             */
            function syncFromEditor() {
                if (currentState === InputState.EDIT) {
                    committed = outputArea.textContent || "";
                }
            }

            /**
             * 切换历史记录面板
             */
            function toggleHistoryPanel() {
                const historyPanel = document.getElementById("historyPanel");
                const isVisible = historyPanel.style.display === "flex"; // Check for 'flex' now
                historyPanel.style.display = isVisible ? "none" : "flex";

                const histBtn = document.getElementById("l-hist-btn");
                histBtn.classList.toggle("active", !isVisible);
            }

            /**
             * 清空所有历史记录
             */
            function clearHistory() {
                if (confirm("确定要清空所有输入历史吗？")) {
                    HISTORY = []; // Clear the in-memory array
                    saveHistory(); // Save empty array and update UI

                }
            }

            /**
             * 删除单个历史记录项
             * @param {number} index - 要删除项的索引
             */
            function deleteHistoryItem(index) {
                if (index >= 0 && index < HISTORY.length) {
                    HISTORY.splice(index, 1); // Remove item from array
                    saveHistory(); // Update localStorage and Refresh UI

                }
            }

            // New function for saving history
            function saveHistory() {
                // Limit history to a certain number of items, e.g., 50
                const maxHistoryItems = 50; 
                if (HISTORY.length > maxHistoryItems) {
                    HISTORY = HISTORY.slice(0, maxHistoryItems);
                }
                localStorage.setItem("ime_history_v18", JSON.stringify(HISTORY));
                updateHistoryUI(HISTORY);
            }

            /**
             * 保存设置
             */
            function saveSettings() {
                localStorage.setItem("ime_settings", JSON.stringify(settings));
                console.log("Settings saved:", settings); // Debugging line
            }

            // Function for handling dictionary import from the modal
            async function handleImport(input) {
                const file = input.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const content = JSON.parse(e.target.result);
                        const newDict = {
                            name: file.name.replace('.json', ''),
                            enabled: true,
                            type: 'user',
                            // Assuming the dictionary content itself is stored for later Trie rebuild
                            // Use 'content' property as previously defined in allDicts structure
                            content: JSON.stringify(content) 
                        };
                        allDicts.push(newDict);
                        saveDictConfig(); // Uses saveDictConfig which handles localStorage and saveSettings
                        
                        await loadAllDicts(); // Rebuild Trie with new dict
                        renderModalDicts(); // Re-render modal to show new dict
                        showToast(`已导入词典: ${newDict.name}`, 'info'); // Use info toast for feedback
                    } catch (error) {
                        console.error('导入词典失败:', error);
                        showToast('导入失败，请检查文件格式', 'error');
                    }
                };
                reader.readAsText(file);
                input.value = ''; // Reset file input
            }

            // --- End Missing function definitions ---

            // --- Init functions ---
            async function initInputHandler() {
                // Attach event listeners for hInput, correctionInput
                // Keep this minimal, actual logic handled by keydown/input listeners
                hInput.addEventListener("keydown", handleKeyDown);
                hInput.addEventListener("input", handleInput);
                correctionInput.addEventListener(
                    "keydown",
                    handleCorrectionKeyDown,
                );
            }

            function initUI() {
                // Initialize UI elements like outputArea, bufferDisplay, mainCandidates
                // Most of this is already done by direct DOM access, but this function
                // serves as a placeholder for more complex UI setup.
            }

            function initEventListeners() {
                // Global event listeners
                document.addEventListener("keydown", handleGlobalKeyDown);
                document.addEventListener("click", handleGlobalClick);
                document.addEventListener(
                    "visibilitychange",
                    handleVisibilityChange,
                );
            }
            // --- End Init functions ---

            const InputState = {
                NORMAL: "normal",
                PRACTICE: "practice",
                EDIT: "edit",
                CORRECTION: "correction",
                TAB: "tab",
            };

            let currentState = InputState.NORMAL;
            function setState(newState) {
                currentState = newState;
                // Manage 'locked' class on outputArea
                if (outputArea) {
                    if (currentState === InputState.NORMAL) {
                        outputArea.classList.add("locked");
                    } else {
                        outputArea.classList.remove("locked");
                    }
                }
                updateFocus();
            }

            function updateFocus() {
                if (currentState === InputState.EDIT) {
                    outputArea.focus();
                } else if (currentState === InputState.CORRECTION) {
                    correctionInput.focus();
                } else {
                    hInput.focus();
                }
            }

            const PUNCS = {
                ",": "，",
                ".": "。",
                "!": "！",
                "?": "？",
                ";": "；",
                ":": "：",
                "(": "（",
                ")": "）",
                "[": "【",
                "]": "】",
            };

            const NON_PINYIN_COMMITTING_CHARS = new Set([
                '+', '-', '\'', '"', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '=',
                '~', '`', '{', '}', '[', ']', '|', '\\', ':', ';', '<', '>', '?', '/'
            ]);

            function getDictLevel(dict) {
                return typeof dict.level === "number" ? dict.level : 100; // Use 100 as per strong recommendation
            }

            class Trie {
                constructor() {
                    this.root = { children: {}, values: [] };
                }

                insert(key, value) {
                    let node = this.root;
                    for (const char of key) {
                        if (!node.children[char]) {
                            node.children[char] = { children: {}, values: [] };
                        }
                        node = node.children[char];
                    }
                    const items = Array.isArray(value) ? value : [value];
                    node.values.push(...items);
                }

                getNode(prefix) {
                    let node = this.root;
                    for (const char of prefix) {
                        if (!node.children[char]) return null;
                        node = node.children[char];
                    }
                    return node;
                }
            }

            let DB = new Trie();
            let allDicts = []; // This will now be loaded directly from localStorage

            let settings = JSON.parse(
                localStorage.getItem("ime_settings") || "{}",
            );
            console.log("Settings loaded:", settings); // Debugging line
            if (typeof settings.outputFlexGrow === "undefined")
                settings.outputFlexGrow = 2;
            if (typeof settings.inputFlexGrow === "undefined")
                settings.inputFlexGrow = 3;
            if (typeof settings.history === "undefined")
                settings.history = true;

            let activeLanguage = "chinese";
            let buffer = "",
                committed = "",
                enFilter = "";

            let combinedCandidates = [],
                pageIndex = 0;
            const pageSize = 10; // Moved pageSize outside InputState logic
            let HISTORY = JSON.parse(
                localStorage.getItem("ime_history_v18") || "[]",
            );

            const hInput = document.getElementById("hidden-input");
            const outputArea = document.getElementById("output-area");
            const correctionWrapper =
                document.getElementById("correction-wrapper");
            const correctionInput = document.getElementById("correction-input");
            const mainCandidates = document.getElementById("main-candidates"); // Define mainCandidates

            async function init() {
                try {
                    console.log("开始初始化输入法...");
                    showLoadingMessage("正在初始化输入法...");

                    // Core components setup
                    await Promise.all([
                        initInputHandler(),
                        initUI(),
                        initEventListeners(),
                    ]);

                    // Load settings and dictionaries
                    loadDictConfig(); // Load allDicts from localStorage or built-in
                    await loadAllDicts(); // Populate the Trie with enabled dicts
                    applySettings(); // Apply saved layout settings

                    // Validate initialization
                    const isValid = validateInitialization();
                    if (!isValid) {
                        throw new Error("初始化验证失败");
                    }

                    // Start input method
                    startInputMethod();

                    console.log("输入法初始化完成");
                    hideLoadingMessage();
                } catch (error) {
                    console.error("输入法初始化失败:", error);
                    showErrorMessage("输入法初始化失败，请刷新页面重试");
                    hideLoadingMessage();
                }
            }

            function validateInitialization() {
                const checks = [
                    {
                        name: "隐藏输入框",
                        check: () => !!document.getElementById("hidden-input"),
                    },
                    {
                        name: "候选词区域",
                        check: () =>
                            !!document.getElementById("main-candidates"),
                    },
                    {
                        name: "Trie树有数据",
                        check: () =>
                            DB.root.children &&
                            Object.keys(DB.root.children).length > 0,
                    },
                ];

                for (const check of checks) {
                    if (!check.check()) {
                        console.error(`初始化检查失败: ${check.name}`);
                        return false;
                    }
                }

                return true;
            }

            // --- Missing function definitions (from gemini.md) ---
            /**
             * 增强的startInputMethod函数，包含历史记录初始化
             */
            function startInputMethod() {
                try {
                    console.log("启动输入法核心功能...");

                    // 初始化历史记录
                    const savedHistory =
                        localStorage.getItem("ime_history_v18");
                    let historyItems = [];

                    if (savedHistory) {
                        try {
                            historyItems = JSON.parse(savedHistory);
                            if (!Array.isArray(historyItems)) {
                                historyItems = [];
                            }
                        } catch (e) {
                            console.warn("历史记录解析失败，重置为空数组");
                            historyItems = [];
                        }
                    }

                    // 更新历史记录UI
                    updateHistoryUI(historyItems);

                    // 绑定历史记录保存
                    // This part needs to be integrated with existing commit logic
                    // For now, let's just make sure the updateHistoryUI is called
                    // on commit in the general update loop or dedicated commit function.

                    // Set initial state and update UI
                    setState(InputState.NORMAL);
                    update();

                    // 显示启动成功消息

                    console.log("输入法启动完成");
                } catch (error) {
                    console.error("启动输入法失败:", error);
                    showErrorMessage("启动输入法失败", error);
                }
            }
            // --- End Missing function definitions ---

            function showErrorMessage(message, error = null) {
                console.error("输入法错误:", message, error);
                showToast(
                    `${message}${error ? ": " + error.message : ""}`,
                    "error",
                    5000,
                );
            }

            // This function now only retrieves allDicts from localStorage and ensures it's initialized
            function loadDictConfig() {
                const storedDicts = JSON.parse(
                    localStorage.getItem("ime_dicts_config"),
                );
                if (storedDicts && storedDicts.length > 0) {
                    // Check if storedDicts is not empty
                    allDicts = storedDicts;
                    // Add any new built-in dicts that aren't already in stored config
                    BUILT_IN_DICTS.forEach((builtInDict) => {
                        if (
                            !allDicts.find(
                                (d) =>
                                    d.path === builtInDict.path &&
                                    d.type === builtInDict.type,
                            )
                        ) {
                            allDicts.push(builtInDict);
                        }
                    });
                } else {
                    allDicts = [...BUILT_IN_DICTS];
                }

                // Initialize practice dicts settings for newly added dicts if not present
                allDicts.forEach((dict, index) => {
                    if (settings.practice_dicts[index] === undefined) {
                        settings.practice_dicts[index] = false; // Default to not selected for practice
                    }
                });
                // No saveDictConfig here, as this is just loading initial state
            }

            function saveDictConfig() {
                localStorage.setItem(
                    "ime_dicts_config",
                    JSON.stringify(allDicts),
                );
                saveSettings(); // Ensure global settings are saved too
            }

            function calculateWordCount(dictContent) {
                let count = 0;
                for (const k in dictContent) {
                    count += Array.isArray(dictContent[k])
                        ? dictContent[k].length
                        : 1;
                }
                return count;
            }

            async function loadAllDicts() {
                DB = new Trie(); // Reset Trie before loading
                console.log("加载词典中...");

                const loadPromises = allDicts
                    .filter((d) => d.enabled) // Only load enabled dictionaries
                    .map((dict) => {
                        return new Promise(async (resolve) => {
                            try {
                                console.log(
                                    `尝试加载词典: ${dict.name} (enabled: ${dict.enabled})`,
                                );
                                let dictData;
                                if (dict.type === "built-in") {
                                    const response = await fetch(dict.path);
                                    if (!response.ok) {
                                        console.error(
                                            `无法加载内置词典 ${dict.name}: ${response.status}`,
                                        );
                                        return resolve(); // Resolve even on error to allow other dicts to load
                                    }
                                    dictData = await response.json();
                                    dict.fetchedContent = dictData; // Store fetched content
                                } else if (
                                    dict.type === "user" &&
                                    dict.content
                                ) {
                                    dictData = JSON.parse(dict.content);
                                }

                                if (dictData) {
                                    let currentWordCount = 0;
                                    for (const k in dictData) {
                                        const key = k.toLowerCase();
                                        const items = Array.isArray(dictData[k])
                                            ? dictData[k]
                                            : [dictData[k]];
                                        DB.insert(key, items);
                                        currentWordCount += items.length;
                                    }
                                    dict.wordCount = currentWordCount; // Update wordCount directly on the dict object
                                }
                            } catch (e) {
                                console.error(
                                    "Failed to load or parse dict:",
                                    dict.name,
                                    e,
                                );
                            }
                            resolve();
                        });
                    });
                await Promise.all(loadPromises);
                console.log("所有启用的词典加载完成。");
            }

            function applySettings() {
                const outputCard = document.getElementById("output-card");
                const inputCard = document.getElementById("input-container");

                if (outputCard) {
                    outputCard.style.flexGrow = settings.outputFlexGrow;
                }
                if (inputCard) {
                    inputCard.style.flexGrow = settings.inputFlexGrow;
                }

                document.getElementById("historyPanel").style.display = // Corrected ID
                    settings.history ? "flex" : "none"; // Changed to flex/none for the panel
                document
                    .getElementById("l-hist-btn")
                    .classList.toggle("active", settings.history);
                console.log(
                    "Applying settings - outputFlexGrow:",
                    settings.outputFlexGrow,
                    "inputFlexGrow:",
                    settings.inputFlexGrow,
                ); // Debugging line
            }

            function update() {
                if (currentState === InputState.EDIT) return;

                outputArea.innerText = committed;
                outputArea.scrollTop = outputArea.scrollHeight;

                if (buffer) {
                    const b = buffer.toLowerCase();
                    let bufferHTML = escapeHtml(b); // Display buffer as typed pinyin
                    if (currentState === InputState.TAB) {
                        bufferHTML += "-";
                        if (enFilter) {
                            bufferHTML += ` <span style="color: #ff9500;">${escapeHtml(enFilter)}</span>`;
                        }
                    }
                    document.getElementById("buffer-display").innerHTML =
                        bufferHTML;

                    let list = [];
                    const isAllVowels = (str) => /^[aeiou]+$/.test(str);

                    let useExactMatch = false;
                    if (
                        b.length <= 2 ||
                        ((b.length === 3 || b.length === 4) && isAllVowels(b))
                    ) {
                        useExactMatch = true;
                    }

                    const prefixNode = DB.getNode(b);

                    if (prefixNode) {
                        const collect = (node, path) => {
                            if (useExactMatch && path !== b) {
                                return;
                            }
                            if (node.values.length > 0) {
                                let weight = 1000;
                                if (path === b) weight += 10000; // Exact match bonus
                                weight -= (path.length - b.length) * 100;

                                node.values.forEach((i) =>
                                    list.push({
                                        text: i.char || i,
                                        desc:
                                            i.en ||
                                            (typeof i === "object" ? i.en : ""),
                                        w: weight,
                                    }),
                                );
                            }

                            if (!useExactMatch) {
                                for (const char in node.children) {
                                    collect(node.children[char], path + char);
                                }
                            }
                        };
                        collect(prefixNode, b);
                    }

                    const seen = new Set();
                    combinedCandidates = list
                        .sort((a, b) => b.w - a.w)
                        .filter((x) => !seen.has(x.text) && seen.add(x.text));

                    if (
                        b.length >= 6 &&
                        DB.getNode(b) &&
                        DB.getNode(b).values.length === 1 &&
                        currentState !== InputState.TAB
                    ) {
                        const word = combinedCandidates[0].text;
                        setTimeout(() => selectCandidate(word), 10);
                        return;
                    }
                } else {
                    document.getElementById("buffer-display").innerText = "";
                    combinedCandidates = [];
                }
                render();
            }

            function escapeHtml(text = "") {
                return String(text)
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            }

            function render() {
                let display = combinedCandidates;
                if (currentState === InputState.TAB && enFilter) {
                    display = combinedCandidates.filter(
                        (i) =>
                            i.desc &&
                            i.desc
                                .toLowerCase()
                                .startsWith(enFilter.toLowerCase()),
                    );
                    if (display.length === 1) {
                        selectCandidate(display[0].text);
                        return;
                    }
                }
                const totalPages = Math.ceil(display.length / pageSize);
                document.getElementById("page-counter").innerText =
                    buffer && display.length > 0
                        ? `${pageIndex + 1} / ${totalPages || 1}`
                        : "";
                const pageData = display.slice(
                    pageIndex * pageSize,
                    (pageIndex + 1) * pageSize,
                );
                document.getElementById("main-candidates").innerHTML = pageData
                    .map(
                        (item, i) => `
                    <div class="candidate-item" onclick="selectCandidate('${item.text}')">
                        <span class="cand-key">${(i + 1) % 10}</span><div class="cand-text">${item.text}</div>
                        ${item.desc ? `<div class="cand-desc">${item.desc}</div>` : ""}
                    </div>`,
                    )
                    .join("");
            }

            function selectCandidate(t) {
                committed += t;
                resetInput();
                update();
            }

            function resetInput() {
                // Before clearing buffer, check if committed has new content to save to history
                // Only save if committed has content AND it's different from the last history item
                // (to avoid duplicate entries if resetInput is called multiple times without new committed content)
                if (committed.trim() && (HISTORY.length === 0 || HISTORY[0].text !== committed.trim())) {
                    const historyItem = {
                        text: committed.trim(),
                        timestamp: Date.now()
                    };
                    HISTORY.unshift(historyItem); // Add to the beginning
                    saveHistory(); // Save the updated history
                }

                setBuffer(""); // Consolidates buffer = "" and hInput.value = ""
                enFilter = "";
                setState(InputState.NORMAL); // Reset tab state
                pageIndex = 0;
            }

            function handleKeyDown(e) {
                if (
                    currentState === InputState.CORRECTION
                )
                    return;
                const key = e.key;

                // Handle correction mode shortcut (Ctrl+I) globally
                if (e.ctrlKey && key.toLowerCase() === "i") {
                    e.preventDefault();
                    enterCorrectionMode();
                    return;
                }

                // --- Normal Mode Logic Below ---

                // Handle specific non-IME characters: +, -, ', etc.
                if (NON_PINYIN_COMMITTING_CHARS.has(key)) {
                    e.preventDefault();
                    if (buffer && combinedCandidates.length > 0) {
                        committed += combinedCandidates[0].text;
                    }
                    committed += key;
                    resetInput();
                    update();
                    return;
                }

                // Punctuation handling for normal mode
                if (PUNCS[key]) {
                    e.preventDefault();
                    if (buffer && combinedCandidates.length > 0)
                        committed += combinedCandidates[0].text;
                    committed += PUNCS[key];
                    resetInput();
                    update();
                    return;
                }

                // Paging candidates with '=' or '-'
                if (buffer && currentState !== InputState.TAB) {
                    if (key === "=") {
                        e.preventDefault();
                        if (
                            (pageIndex + 1) * pageSize <
                            combinedCandidates.length
                        ) {
                            pageIndex++;
                            render();
                        }
                        return;
                    }
                    if (key === "-") {
                        e.preventDefault();
                        if (pageIndex > 0) {
                            pageIndex--;
                            render();
                        }
                        return;
                    }
                }

                // TAB key handling
                if (key === "Tab") {
                    e.preventDefault();
                    if (buffer) {
                        setState(
                            currentState === InputState.TAB
                                ? InputState.NORMAL
                                : InputState.TAB,
                        );
                        enFilter = "";
                        update();
                    }
                    return;
                }

                // TAB mode specific char/backspace
                if (currentState === InputState.TAB && buffer) {
                    if (/^[a-zA-Z]$/.test(key)) {
                        e.preventDefault();
                        enFilter += key.toLowerCase();
                        pageIndex = 0;
                        render();
                        return;
                    }
                    if (key === "Backspace") {
                        e.preventDefault();
                        if (enFilter) {
                            enFilter = enFilter.slice(0, -1);
                            render();
                        } else {
                            setState(InputState.NORMAL);
                            update();
                        }
                        return;
                    }
                }

                // Numeric selection '0'-'9' for normal mode
                if (/^[0-9]$/.test(key)) {
                    e.preventDefault();
                    if (buffer && combinedCandidates.length > 0) {
                        const idx = key === "0" ? 9 : parseInt(key) - 1;
                        const list =
                            currentState === InputState.TAB && buffer
                                ? combinedCandidates.filter(
                                      (c) =>
                                          c.desc &&
                                          c.desc
                                              .toLowerCase()
                                              .startsWith(enFilter),
                                  )
                                : combinedCandidates;
                        const pageData = list.slice(
                            pageIndex * pageSize,
                            (pageIndex + 1) * pageSize,
                        );
                        if (pageData[idx]) selectCandidate(pageData[idx].text);
                    } else if (!buffer) {
                        committed += key;
                        update();
                    }
                } else if (key === "Enter") {
                    // Enter key for normal mode
                    e.preventDefault();
                    if (buffer) {
                        committed += buffer;
                        resetInput();
                    } else {
                        committed += "\n";
                    }
                    update();
                } else if (key === "Backspace") {
                    // Backspace for normal mode
                    e.preventDefault();
                    if (buffer) {
                        buffer = buffer.slice(0, -1);
                        hInput.value = buffer;
                        update();
                    } else if (committed) {
                        committed = committed.slice(0, -1);
                        update();
                    }
                } else if (key === " ") {
                    // Space for normal mode
                    e.preventDefault();
                    if (buffer) {
                        const list =
                            currentState === InputState.TAB && buffer
                                ? combinedCandidates.filter(
                                      (c) =>
                                          c.desc &&
                                          c.desc
                                              .toLowerCase()
                                              .startsWith(enFilter),
                                  )
                                : combinedCandidates;
                        const pageData = list.slice(
                            pageIndex * pageSize,
                            (pageIndex + 1) * pageSize,
                        );
                        if (pageData[0]) selectCandidate(pageData[0].text);
                    } else {
                        committed += " ";
                        update();
                    }
                }
            }

            function handleInput() {
                if (
                    currentState !== InputState.TAB &&
                    currentState !== InputState.EDIT
                ) {
                    setBuffer(hInput.value.replace(/[^a-zA-Z]/g, ""));
                    pageIndex = 0;
                    update();
                }
            }

            function handleGlobalKeyDown(e) {
                const key = e.key.toLowerCase();
                if (e.ctrlKey && key === "e") {
                    e.preventDefault();
                    toggleEditMode();
                    return;
                }
                if (e.ctrlKey && key === "c") {
                    if (
                        currentState !== InputState.EDIT &&
                        currentState !== InputState.CORRECTION
                    ) {
                        e.preventDefault();
                        archiveAndCopy();
                    }
                    return;
                }
                if (e.key === "escape") {
                    if (currentState === InputState.EDIT)
                        setState(InputState.NORMAL);
                    if (currentState === InputState.CORRECTION) {
                        e.preventDefault();
                        exitCorrectionMode("update_buffer");
                    }
                }
            }

            function handleCorrectionKeyDown(e) {
                if (e.key === "Enter") {
                    e.preventDefault();
                    exitCorrectionMode("convert_sentence");
                } else if (e.key === "Escape") {
                    e.preventDefault();
                    exitCorrectionMode('sync_out_buffer'); // Sync Out: Escape key
                } else if (e.ctrlKey && e.key.toLowerCase() === "i") {
                    e.preventDefault();
                    exitCorrectionMode("convert_sentence");
                }
            }

            function handleGlobalClick(e) {
                if (
                    currentState === InputState.EDIT &&
                    outputArea.contains(e.target)
                )
                    return;
                if (
                    currentState === InputState.CORRECTION &&
                    correctionWrapper.contains(e.target)
                )
                    return;
                // Clicking on import button is now handled by settings.html, remove from index.html
                // if (e.target.id === "file-uploader") return;
                updateFocus(); // Keep focus where it should be based on state
            }

            function handleVisibilityChange() {
                if (!document.hidden) updateFocus(); // Restore focus on tab switch
            }

            function makeResizableV(resizerId, topPanelId, bottomPanelId) {
                const resizer = document.getElementById(resizerId);
                const topPanel = document.getElementById(topPanelId);
                const bottomPanel = document.getElementById(bottomPanelId);
                const parentPanel = topPanel.parentElement; // Should be center-container

                let startY, startTopFlexGrow, startBottomFlexGrow, totalHeight, parentRect;

                resizer.addEventListener("mousedown", (e) => {
                    e.preventDefault();
                    
                    // Get current computed flex-grow values
                    startTopFlexGrow = parseFloat(window.getComputedStyle(topPanel).flexGrow);
                    startBottomFlexGrow = parseFloat(window.getComputedStyle(bottomPanel).flexGrow);

                    // If not set, use default or initial values
                    if (isNaN(startTopFlexGrow) || startTopFlexGrow === 0) startTopFlexGrow = 2;
                    if (isNaN(startBottomFlexGrow) || startBottomFlexGrow === 0) startBottomFlexGrow = 3;

                    totalHeight = parentPanel.offsetHeight; // Total height of the flex container
                    parentRect = parentPanel.getBoundingClientRect(); // Get bounding rect once

                    const doDrag = (ev) => {
                        // Calculate mouse position relative to the parentPanel
                        const mouseY = ev.clientY - parentRect.top;
                        
                        // Calculate new top panel height based on mouse position
                        let newTopHeight = mouseY;
                        let newBottomHeight = parentRect.height - mouseY;

                        // Ensure minimum heights
                        const minHeight = 100; // Define a reasonable minimum height
                        if (newTopHeight < minHeight) {
                            newTopHeight = minHeight;
                        }
                        if (newBottomHeight < minHeight) {
                            newBottomHeight = minHeight;
                        }

                        // Calculate new flex-grow ratios based on the adjusted split point
                        const sumFlexGrow = startTopFlexGrow + startBottomFlexGrow;
                        
                        let newTopFlexGrow = (newTopHeight / parentRect.height) * sumFlexGrow;
                        let newBottomFlexGrow = sumFlexGrow - newTopFlexGrow;

                        requestAnimationFrame(() => {
                            topPanel.style.flexGrow = newTopFlexGrow;
                            bottomPanel.style.flexGrow = newBottomFlexGrow;
                        });
                    };

                    const stopDrag = () => {
                        document.removeEventListener("mousemove", doDrag);
                        document.removeEventListener("mouseup", stopDrag);

                        // Save the final flex-grow values
                        settings.outputFlexGrow = parseFloat(
                            topPanel.style.flexGrow,
                        );
                        settings.inputFlexGrow = parseFloat(
                            bottomPanel.style.flexGrow,
                        );
                        saveSettings();
                    };

                    document.addEventListener("mousemove", doDrag);
                    document.addEventListener("mouseup", stopDrag);
                });
            }

            document.addEventListener("DOMContentLoaded", () => {
                makeResizableV(
                    "center-v-resizer",
                    "output-card",
                    "input-container",
                );
                init();
            });
        </script>
    </body>
</html>
